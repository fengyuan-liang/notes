# 系统架构设计师

> https://www.bilibili.com/video/BV1Ba4y1u7EC/?p=8&share_source=copy_web&vd_source=ec1efc27188fd12728ac85b30861f139

# 0x00. 学习攻略

>考试内容

![image-20240310192931706](https://cdn.fengxianhub.top/resources-master/image-20240310192931706.png)

## 考试重点

### 科目一

![image-20240310224056571](https://cdn.fengxianhub.top/resources-master/image-20240310224056571.png)

![image-20240310224114641](https://cdn.fengxianhub.top/resources-master/image-20240310224114641.png)

### 科目二

案例分析是五个大题里选三个，第一个必做，剩下四个里面选两个

其中有一些是填空题，必做，比如2024年上半年就考了redis的命令，比如zset的`zrangebyscore` 命令

![image-20241027142940059](https://cdn.fengxianhub.top/resources-master/image-20241027142940059.png)



### 科目三

官方教程下篇的8大架构

- 信息系统架构设计
- 层次架构设计
- 云原生架构设计
- 面向服务的架构设计SOA
- 嵌入式系统
- 通信系统架构设计
- 安全架构
- 大数据架构设计

考前尽每种背一篇范文，并且准备多套万能开头和结尾

## 备考时间线（3个月时间准备）

![image-20240219215817347](https://cdn.fengxianhub.top/resources-master/image-20240219215817347.png)

![image-20240219215928545](https://cdn.fengxianhub.top/resources-master/image-20240219215928545.png)

![image-20240219220020846](https://cdn.fengxianhub.top/resources-master/image-20240219220020846.png)

![image-20240219220034661](https://cdn.fengxianhub.top/resources-master/image-20240219220034661.png)

## 学习建议

![image-20240219220701339](https://cdn.fengxianhub.top/resources-master/image-20240219220701339.png)

## 考点分布

# 1. 系统工程

## 1.1 系统工程方法

### 1.1.1 霍尔三维

重点是`霍尔三维结构`

- 逻辑维
- 时间维
- 知识维

![image-20240406135018971](https://cdn.fengxianhub.top/resources-master/image-20240406135018971.png)

根据霍尔三维结构，我们可以分辨出下面三个部分分别为：逻辑维、时间维和知识维

![image-20240310231031865](https://cdn.fengxianhub.top/resources-master/image-20240310231031865.png)

### 1.1.2 生命周期

![image-20240406140109294](https://cdn.fengxianhub.top/resources-master/image-20240406140109294.png)

 >信息系统生命周期

![image-20240406140601333](https://cdn.fengxianhub.top/resources-master/image-20240406140601333.png)

>信息系统建设原则（`论文写作的支撑`）

![image-20240406141111798](https://cdn.fengxianhub.top/resources-master/image-20240406141111798.png)

## 1.2 信息系统开发方法

>- 结构化（自顶向下）
>- 原型方法
>- 面向对象（自底向上）
>- 面向服务
>- 形式化（数学模型化）

结构化的思想是`自顶向下`，逐步分解求精

- 开发目标清晰化
- 工作阶段程式化
- 开发文档结构化
- 设计方法结构化

优点是适合大项目，需求变化不多的项目；缺点是`应变能力差`

![image-20240406144020139](https://cdn.fengxianhub.top/resources-master/image-20240406144020139.png)

其他系统开发方法

![image-20240406145714599](https://cdn.fengxianhub.top/resources-master/image-20240406145714599.png)

### 1.2.1 例题

![image-20240406145808049](https://cdn.fengxianhub.top/resources-master/image-20240406145808049.png)

>答案：自顶向下（结构化）、自底向上（面向对象）、形式化方法

## 1.3 信息系统的分类

>重点是ES、OAS、ERP

![image-20240406150752662](https://cdn.fengxianhub.top/resources-master/image-20240406150752662.png)

### 1.3.1 业务处理系统 TPS

![image-20240406151041457](https://cdn.fengxianhub.top/resources-master/image-20240406151041457.png)

该系统已经过时，但是其中的一些思想比如`批处理`还是值得学习的



### 1.3.2 管理信息系统 MIS

>其中开环闭环结构在下午的论文写作知识点中还会详细介绍

![image-20240406151554745](https://cdn.fengxianhub.top/resources-master/image-20240406151554745.png)

![image-20240406151814570](https://cdn.fengxianhub.top/resources-master/image-20240406151814570.png)

### 1.3.3 决策系统 DSS

![image-20240406152316787](https://cdn.fengxianhub.top/resources-master/image-20240406152316787.png)

### 1.3.4 专家系统

![image-20240406152456466](https://cdn.fengxianhub.top/resources-master/image-20240406152456466.png)

![image-20240406153616426](https://cdn.fengxianhub.top/resources-master/image-20240406153616426.png)

# 2. 软件工程

## 2.1 软件过程模型

![image-20240406154748458](https://cdn.fengxianhub.top/resources-master/image-20240406154748458.png)

**对比如下**

![image.png](https://cdn.fengxianhub.top/resources-master/5c65e48a302774d13e6f3276d19e219b.png)



### 2.1.1 瀑布模型

>瀑布模型的缺点是：只适合`需求明确`的项目
>
>答题要点：只要不涉及【需求明确】的场景，一般不要选择瀑布模型

![image-20240406155526433](https://cdn.fengxianhub.top/resources-master/image-20240406155526433.png)

### 2.1.2 原型模型

>软件需求本身不确定，瀑布模型就是因为按照客户不确定的需求开发的软件和客户最终想要的可能不一致，才导致失败率比较高的
>
>所以原型模型就是先精简化流程，开发出一个最小可用的软件（MVP）交付给客户，看看是不是客户想要的，如果不是再进行修改，如此反复，得到最终的产品
>
>特点：适合`需求不明确`的项目，后续可能会演化成其他模型进行开发
>
>系统开发中，原型可以划分为不同的种类。从原型是否实现功能来分，可以分为`水平原型`和`垂直原型`；从原型最终结果来分，可以分为`抛弃式原型`和`演化式原型`
>
>- 水平原型主要用在界面上。
>
>- 垂直原型主要用在复杂的算法实现上,抛弃式原型主要用于界面设计。
>
>- 抛弃式原型基本思路就是开始就做一个简单的界面设计，用来让用户有直观感受，从而可以提得出需求，等需求获取到之后，可以把这个界面原型抛弃不用。
>
>- 演化式原型主要用在必须易于升级和优化的场合，适合于Web项目。



![image-20240406190219714](https://cdn.fengxianhub.top/resources-master/image-20240406190219714.png)

### 2.1.3 V模型

>在瀑布模型中，将测试放到最后进行作业，容易导致之前的工作白费
>
>V模型讲究的是：测试贯穿于始终，测试分阶段，测试计划提前

![image-20240406191259884](https://cdn.fengxianhub.top/resources-master/image-20240406191259884.png)

### 2.1.4 迭代与增量

>增量型：看下图左边的部分，讲究的是局部增加，但局部要和完成的作品一致
>
>迭代：右边部分，讲究的是由简单到复杂的过程
>
>很多场景下，都是增量和迭代同时进行，所以比较难区分

![image-20240406191930400](https://cdn.fengxianhub.top/resources-master/image-20240406191930400.png)

### 2.1.5 螺旋模型

>典型特点：`引入风险分析`，螺旋模型是在`快速原型`的基础上扩展而成的。
>
>下面的图从【原型1】开始，每一圈都是`瀑布模型`，每一圈的成果都是下一圈的`原型`，所以同时具备了瀑布模型和原型模型的优点。螺旋模型属于比较重的模型，比较适合开发大型软件
>
>分为四个阶段：
>
>- 目标设定
>- 风险分析
>- 开发和有效性验证
>- 评审

![image-20240406192805070](https://cdn.fengxianhub.top/resources-master/image-20240406192805070.png)

### 2.1.6 构件组装模型

>刚开始成本比较高，但是易拓展、重用

![image-20240406195239160](https://cdn.fengxianhub.top/resources-master/image-20240406195239160.png)

**构件组装阶段失配问题**

1. 由构件引起的失配，包括由于系统对构建基础设施，构建控制模型和构建数据模型的假设存在冲突引起的失配
2. 由连接子引起的失配，包括由于系统对构建交互协议、连接子数据模型的假设存在冲突引起的失配
3. 由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题，首先需要检测出失配问题，并在此基础上通过适当的手段消除检测的适配问题



### 2.1.7 基于构件的软件工程（CBSE）

![image-20240406195520562](https://cdn.fengxianhub.top/resources-master/image-20240406195520562.png)

![image-20240406195659076](https://cdn.fengxianhub.top/resources-master/image-20240406195659076.png)

### 2.1.8 快速应用开发模型(RAD)

> 由多个模型组成
>
> 快速应用开发是一种比传统生存周期法快得多的开发方法，它强调极短的开发周期。 RAD 模型是瀑布模型的一个高速变种，通过使用基于`构件`的开发方法获得快速开发。如果对 需求理解得很好且约束了项目范围， 利用这种模型可以很快地开发出功能完善的信息系统。 但是 RAD 也具有以下局限性。
>
> （1） 并非所有应用都适合 RAD，RAD 对模块化要求比较高。如果有哪一项功能不能被模块化， 那么 RAD 所需要的构件就会有问题； 如果高性能是一个指标且该指标必须通过调 整接口使其适应系统构件才能获得， 则 RAD 也可能不能奏效。
>
> （2） 开发者和客户必须在很短的时间完成一系列的需求分析， 任何一方配合不当都会导致 RAD 项目失败。
>
> （3） RAD只能用于管理信息系统的开发，不适合技术风险很高的情况。例如，当一个新系统要采用很多新技术，或当新系统与现有系统有较高的互操作性时就不适合使用RAD。

![image-20240406195928890](https://cdn.fengxianhub.top/resources-master/image-20240406195928890.png)

### 2.1.9 统一过程（up/rup）

>典型特点是用例驱动、以架构为中心、迭代和增量
>
>分为`四个阶段，九个核心工作流`
>
>- 每一个阶段都由一个或多个连续的选代（iteration）组成。迭代并不是重复地做相同的事，而是针对不同用例的细化和实现。`每一个迭代都是一个完整的开发过程`，它需要项目经理根据当前迭代所处的阶段以及上次迭代的结果，适当地对核心工作流中的行为进行裁剪。

![image-20240406200203056](https://cdn.fengxianhub.top/resources-master/image-20240406200203056.png)

![image-20240406200301074](https://cdn.fengxianhub.top/resources-master/image-20240406200301074.png)

### 2.1.10 敏捷方法

![image-20240406204230805](https://cdn.fengxianhub.top/resources-master/image-20240406204230805.png)

![image-20240406204306526](https://cdn.fengxianhub.top/resources-master/image-20240406204306526.png)



>可能会考下面哪些属于敏捷开发，前四种比较重要
>
>- 水晶方法：具有家族得概念，其家族实际上是一组经过证明，对不同类型项目非常有效得敏捷过程

![image-20240406204557374](https://cdn.fengxianhub.top/resources-master/image-20240406204557374.png)



### 2.1.11 喷泉模型





### 2.1.12 例题

![image-20240406201507316](https://cdn.fengxianhub.top/resources-master/image-20240406201507316.png)

需要注重每个模型的重点：

- 原型模型：不强调阶段，强调的是尽快构件最小可用交付产品
- 瀑布模型：需求评审、开发、测试等等流程
- V模型：测试贯穿始终
- 螺旋模型：关键点，`风险分析`

![image-20240406203112665](https://cdn.fengxianhub.top/resources-master/image-20240406203112665.png)

![image-20240420175835429](https://cdn.fengxianhub.top/resources-master/image-20240420175835429.png)

## 2.2 逆向工程

![image-20240420180047080](https://cdn.fengxianhub.top/resources-master/image-20240420180047080.png)

>逆向工程相关概念

![image-20240420195525219](https://cdn.fengxianhub.top/resources-master/image-20240420195525219.png)

### 2.2.1 例题

![image-20240420200211310](https://cdn.fengxianhub.top/resources-master/image-20240420200211310.png)



## 2.3 净室软件工程

>跟后面的`模型驱动架构`有紧密关联

![image-20240420200820100](https://cdn.fengxianhub.top/resources-master/image-20240420200820100.png)

![image-20240420200907615](https://cdn.fengxianhub.top/resources-master/image-20240420200907615.png)

## 2.4 需求工程

![image-20240420201754600](https://cdn.fengxianhub.top/resources-master/image-20240420201754600.png)

软件需求规格说明书SRS中，约束类型包括，设计约束和过程约束

>需求是多层次的，包括`业务需求`、`用户需求`和`系统需求`，这三个不同层次从目标到具体，从整体到局部，从概念到细节。
>
>1. **功能性需求（Functional Requirements）**
>   - 描述系统**“做什么”**，即具体的功能和行为。
>2. **非功能性需求（Non-Functional Requirements, NFR）**
>   - 描述系统**“如何做”**，包括性能、安全性、兼容性等质量属性。
>3. **业务需求（Business Requirements）**
>   - 描述**企业或用户的宏观目标**（如“提高安全性”）。
>4. **用户需求（User Requirements）**
>   - 从用户角度描述**具体的使用场景或体验**（如“3秒内保存”）。

需求分类，软件需求包括三个不同的层次：业务需求、用户需求、功能需求

- 业务需求反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中给予说明
- 用户需求描述了用户使用产品必须要完成的任务，这在用例文档或者方案脚本中说明给予说明
- 功能需求定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求



### 2.4.1 例题

![image-20240420202518561](https://cdn.fengxianhub.top/resources-master/image-20240420202518561.png)

### 2.4.2 需求获取

![image-20240420205424580](https://cdn.fengxianhub.top/resources-master/image-20240420205424580.png)

![image-20240420211249413](https://cdn.fengxianhub.top/resources-master/image-20240420211249413.png)

### 2.4.3 需求分析

需求分析可以分为`结构化需求分析`和面向对象里面的`面向对象需求分析`，一般有以下模型

![image-20240420211935942](https://cdn.fengxianhub.top/resources-master/image-20240420211935942.png)

>在结构化开发中其实比较注重`功能模型`和`数据模型`
>
>- 信息建模 => ER图（实体联系图）
>- 功能建模 => 数据流图
>- 行为建模（如算法步骤）=> 流程图
>
>结构化分析方法的基本思想是自顶向下，逐层分解。把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。经过逐层分解，每个最低层的问题都是足够简单、 容易解决的。
>
>结构化方法分析模型的核心是`数据字典`，围绕这个核心， 有 3 个层次的模型， 分别是`数据模型`、`功能模型`和`行为模型`(也称为“状态模型”) 。
>
>- 在实际工作中一般使用 E-R图表示数据模型
>- 用 DFD 表示功能模型
>- 用状态转换图表示行为模型。
>
>这 3 个模型有密切的关系，它们的建立不具有严格的时序性，而是一个迭代的过程。

>功能模型中非常重要的一个部分就是`数据流图（DFD）`

下面的数据流图中，上部分的比较笼统，下部分的结构更加简明（被称之为`0图`）

- 数据流：图中的`注册请求`、`课程安排`
- 加工：数据进来后需要进行处理，这个处理的过程（函数）就是加工
- 数据存储：数据表、数据库
- 外部实体：不在我系统之内，但需要跟整个系统进行交互。例如下图的`学员`、`培训部`

![image-20240420212505793](https://cdn.fengxianhub.top/resources-master/image-20240420212505793.png)

![image-20240420213522390](https://cdn.fengxianhub.top/resources-master/image-20240420213522390.png)

### 2.4.4 UML

UML为统一建模语言，由构造块、规则和公共机制组成，重点是`构造块`

>基于UML的需求分析过程的基本步骤为：利用`用例及用例图`表示需求；利用 `包图及类图`表示目标软件系统的总体架构。

![image-20240420223821866](https://cdn.fengxianhub.top/resources-master/image-20240420223821866.png)

![image-20240420224643755](https://cdn.fengxianhub.top/resources-master/image-20240420224643755.png)

#### 2.4.4.1 顺序图

![image-20241103204443590](https://cdn.fengxianhub.top/resources-master/image-20241103204443590.png)

>顺序图，强调的是对象之间消息发送的顺序，越靠上时间越早，越靠下时间越晚
>
>特点：表现细节交互，按时间顺序。在题目中，要有对业务流程的非常详细的描述

#### 2.4.4.2 通信图

![image-20241103225844965](https://cdn.fengxianhub.top/resources-master/image-20241103225844965.png)

#### 2.4.4.3 状态图

![image-20241103225937250](https://cdn.fengxianhub.top/resources-master/image-20241103225937250.png)

#### 2.4.4.4 状态图case-订单场景

![image-20241103230041393](https://cdn.fengxianhub.top/resources-master/image-20241103230041393.png)

**答案**

![image-20241103230101310](https://cdn.fengxianhub.top/resources-master/image-20241103230101310.png)



#### 2.4.4.5 活动图

![image-20241103230605597](https://cdn.fengxianhub.top/resources-master/image-20241103230605597.png)

#### 2.4.4.6 泳道活动图

![image-20241103231035651](https://cdn.fengxianhub.top/resources-master/image-20241103231035651.png)

#### 2.4.4.7 用例图

>用例图主要用来描述角色以及角色与用例之间的**连接关系**。说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了**多个模型元素**，如系统、参与者和用例，并且**显示这些元素之间的各种关系**，如**泛化**、**关联**和**依赖**。它展示了一个外部用户能够观察到的系统功能模型图。
>
>【用途】：帮助开发团队以一种可视化的方式理解系统的功能需求。
>
>https://www.cnblogs.com/lcword/p/10472040.html

用例图中存在的关系有：

| 关联类型 | 说明                                                         | 符号                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 关联     | 参与者与用例之间的关系                                       | <img src="https://cdn.fengxianhub.top/resources-master/image-20251003160223126.png" alt="image-20251003160223126" style="zoom: 67%;" /> |
| 泛化     | 参与者之间或用例之间的关系                                   | <img src="https://cdn.fengxianhub.top/resources-master/image-20251003160340406.png" alt="image-20251003160340406" style="zoom: 50%;" /> |
| 包含     | 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤     | ![image-20251003160640339](https://cdn.fengxianhub.top/resources-master/image-20251003160640339.png) |
| 拓展     | 扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能 | ![image-20251003160703905](https://cdn.fengxianhub.top/resources-master/image-20251003160703905.png) |









### 2.4.5 UML 4+1视图

![image-20240420224953749](https://cdn.fengxianhub.top/resources-master/image-20240420224953749.png)

1995年Kruchten提出了著名的“4+1” 视图，“4+1视图” 从5个不同的侧面来描述架构，其中包括4个主视图和一个冗余的场景视图。4个主视图分别如下：

- **逻辑视图（Logical View**）：对象模型和对象之间的关系。逻辑视图主要支持系统的功能需求，即系统提供给最终用户的服务。在逻辑视图中，系统分解成一系列的功能抽象，这些抽象主要来自问题领域。这种分解不但可以用来进行功能分析，而且可用作标识在整个系统的各个不同部分的通用机制和设计元素。在OO技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。逻辑视图中使用的风格为面向对象的风格，在设计中要注意保持一个单一的、内聚的对象模型贯穿整个系统。
- **进程视图（Process view）**：并发与同步特征。进程视图侧重于系统的运行特性，主要关注一些非功能性需求，例如，系统的性能和可用性等。进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的功能抽象如何适合进程结构等，它也定义了逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。进程视图可以描述成多层抽象，每个级别分别关注不同的方面。
- **物理视图（Physical view ）**：定义软件到硬件的映射，反映架构的分布式特性。物理视图在UML中被称为部署视图，它主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装和通信等问题。当软件运行于不同的物理节点上时，各视图中的构件都直接或间接地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时，对系统其他视图的影响最小化。
- **开发视图(Development View)**：软件模块的组织与管理。开发视图也称为模块视图，在UML中被称为实现视图，它主要侧重于软件模块的组织和管理。开发视图要考虑软件内部的需求，例如，软件开发的容易性、软件复用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。开发视图通过系统I/O关系的模型图和子系统图来描述。

> 例题

![image-20240502154614370](https://cdn.fengxianhub.top/resources-master/image-20240502154614370.png)

### 2.4.6 需求定义&验证



![image-20240420231218491](https://cdn.fengxianhub.top/resources-master/image-20240420231218491.png)

>例题

![image-20240420231439586](https://cdn.fengxianhub.top/resources-master/image-20240420231439586.png)



>需求验证

![image-20240502164249473](https://cdn.fengxianhub.top/resources-master/image-20240502164249473.png)

### 2.4.7 需求跟踪

![image-20240421233624733](https://cdn.fengxianhub.top/resources-master/image-20240421233624733.png)

### 2.4.8 需求变更

>CCB：需求变更委员会

![image-20240421233249987](https://cdn.fengxianhub.top/resources-master/image-20240421233249987.png)

例题

![image-20240421233746124](https://cdn.fengxianhub.top/resources-master/image-20240421233746124.png)

## 2.5 软件系统建模

![image-20240422000532202](https://cdn.fengxianhub.top/resources-master/image-20240422000532202.png)

## 2.6 人机界面设计（黄金三法则）

![image-20240422000841869](https://cdn.fengxianhub.top/resources-master/image-20240422000841869.png)

### 2.6.1 例题

![image-20240422000909532](https://cdn.fengxianhub.top/resources-master/image-20240422000909532.png)

## 2.7 结构化设计

![image-20240422001310654](https://cdn.fengxianhub.top/resources-master/image-20240422001310654.png)

### 2.7.1 内聚

![image-20240422001552060](https://cdn.fengxianhub.top/resources-master/image-20240422001552060.png)

### 2.7.2 耦合

![image-20240422001744356](https://cdn.fengxianhub.top/resources-master/image-20240422001744356.png)

### 2.7.3 模块四要素

![image-20240422002103818](https://cdn.fengxianhub.top/resources-master/image-20240422002103818.png)



## 2.8 面向对象设计



### 2.8.1 类的分类

![image-20240422234941931](https://cdn.fengxianhub.top/resources-master/image-20240422234941931.png)





## 2.9 设计模式

>https://blog.fengxianhub.top/#/设计模式/设计模式

![image-20240502234006725](https://cdn.fengxianhub.top/resources-master/image-20240502234006725.png)



## 2.10 软件测试

![image-20240503001755687](https://cdn.fengxianhub.top/resources-master/image-20240503001755687.png)

### 2.10.1 黑白盒测试

![image-20240503002209584](https://cdn.fengxianhub.top/resources-master/image-20240503002209584.png)

>例题

![image-20240503002756067](https://cdn.fengxianhub.top/resources-master/image-20240503002756067.png)

### 2.10.2 测试阶段

![image-20240503003216210](https://cdn.fengxianhub.top/resources-master/image-20240503003216210.png)



![image-20240503003913212](https://cdn.fengxianhub.top/resources-master/image-20240503003913212.png)

- 我们把依赖驱动模型的称之为`驱动模块`，驱动模块也是桩模块的一种

### 2.10.3 系统测试

![image-20240503004653339](https://cdn.fengxianhub.top/resources-master/image-20240503004653339.png)

>例题

![image-20240503005039384](https://cdn.fengxianhub.top/resources-master/image-20240503005039384.png)

![image-20240503005127370](https://cdn.fengxianhub.top/resources-master/image-20240503005127370.png)

### 2.10.4 软件调试

![image-20240503005648108](https://cdn.fengxianhub.top/resources-master/image-20240503005648108.png)



![image-20240503005700002](https://cdn.fengxianhub.top/resources-master/image-20240503005700002.png)

## 2.11 系统转换计划

![image-20240503010607656](https://cdn.fengxianhub.top/resources-master/image-20240503010607656.png)

- 继承是为了兼容老系统的功能模型（DFD）和数据模型（ER），之前的系统过时了，所以是继承低水平（技术）高价值（业务）
- 改造是为了增强，需要的是高水平高价值的系统

>例题

![image-20240503010939595](https://cdn.fengxianhub.top/resources-master/image-20240503010939595.png)

 

![image-20240503154616789](https://cdn.fengxianhub.top/resources-master/image-20240503154616789.png)

## 2.12 系统运行与维护

**软件的维护**

![image-20240503154945165](https://cdn.fengxianhub.top/resources-master/image-20240503154945165.png)

>例题

![image-20240503155307314](https://cdn.fengxianhub.top/resources-master/image-20240503155307314.png)

# 3. 软件架构设计

>这一章分为架构设计和案例特训架构设计
>
>分别对应上午和下午的考试

![image-20240503161544443](https://cdn.fengxianhub.top/resources-master/image-20240503161544443.png)

## 3.1 软件架构的概念

架构的本质

1. 软件架构为软件系统提供了一个`结构、行为和属性的高级抽象`
2. 软件架构风格是特定应用领域的`惯用模式`，架构定义`一个词汇表和一组约束`
3. 架构风格反映领域中众多系统所共有的结构和语义特征。

架构的作用

1. 软件架构是`项目干系人进行交流的手段`
2. 软件架构是`可传递和可复用的模型`，通过研究软件架构可能预测软件的质量
3. 软件架构使推理和控制的更改更加简单，`有助于循序渐进的原型设计`，可以作为培训的基础

![image-20240503163356215](https://cdn.fengxianhub.top/resources-master/image-20240503163356215.png)

>例题

![image-20240503163722746](https://cdn.fengxianhub.top/resources-master/image-20240503163722746.png)

- 应该主要是为了满足用户的非功能需求

>软件构件
>
>软件架构设计主要关注软件构件的结构、属性和交互作用 ，并通过多种视图全面描述特定系统的架构

**总结与关系**

| 概念       | **角色** | **关注点** | **在失配中的定位**                       |
| :--------- | :------- | :--------- | :--------------------------------------- |
| **构件**   | 功能单元 | “做什么”   | **构件失配**的主体和根源                 |
| **模型**   | 设计蓝图 | “如何设计” | 导致失配的**原因范畴**（如数据模型冲突） |
| **协议**   | 交互规则 | “如何对话” | **连接子失配**的核心内容之一             |
| **连接子** | 交互媒介 | “如何连接” | **连接子失配**的主体和解决方案载体       |

## 3.2 软件发展历程

![image-20240503163832666](https://cdn.fengxianhub.top/resources-master/image-20240503163832666.png)

### 3.2.1 架构的4+1视图

![image-20240503165607101](https://cdn.fengxianhub.top/resources-master/image-20240503165607101.png)

>例题

![image-20240503165728361](https://cdn.fengxianhub.top/resources-master/image-20240503165728361.png)

## 3.3 软件架构风格ADL

![image-20240503171547014](https://cdn.fengxianhub.top/resources-master/image-20240503171547014.png)

>例题

![image-20240503171632895](https://cdn.fengxianhub.top/resources-master/image-20240503171632895.png)

## 3.4 基于架构的软件开发方法(ABSD)

###  3.4.1 概念

>ABSD方法是一个`自顶向下`，`递归细化`的方法，软件系统的体系结构通过该方法得到细化，直到能产生`软件构件和类`
>
>- 它强调采用`视角与视图`描述软件架构，用`用例与质量场景`来描述需求
>- 使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，并且设计活动的开始并不意味着需求抽取和分析活动可以终止，而是应该与设计活动并行
>- 在一个主版本的软件架构分析之后，要安排一次由外部人员 (`用户代表和领域专家`）参加的复审，即主要由`用户代表`与`领域专家`进行
>- 架构文档要保持较新，但不要随时保证文档最新，要保持文档的稳定性
>- ABSD方法是体系结构驱动，即指构成体系结构的`商业、质量和功能需求`的组合驱动的。
>
>架构需求来源有：
>
>- 系统质量目标
>- 系统商业目标
>- 开发人员商业目标
>
>ABSD方法有三个基础
>
>1. 第一个基础是功能分解，在功能分解中使用已有的基于模块的内聚和耦合技术
>2. 第二个基础是通过选择体系结构风格来实现质量和商业需求
>3. 第三个基础是软件模板的使用

![image-20240503173217634](https://cdn.fengxianhub.top/resources-master/image-20240503173217634.png)

### 3.4.2 开发过程

![image-20240503173801690](https://cdn.fengxianhub.top/resources-master/image-20240503173801690.png)

**`架构文档要保持较新，但不要随时保证文档最新，要保持文档的稳定性。架构文档化的主要输出结果是架构规格说明书和架构质量说明书。`**

>结构设计过程

![image-20240503174032690](https://cdn.fengxianhub.top/resources-master/image-20240503174032690.png)

>架构演化过程

![image-20240503174545383](https://cdn.fengxianhub.top/resources-master/image-20240503174545383.png)



>例题

![image-20240503174922938](https://cdn.fengxianhub.top/resources-master/image-20240503174922938.png)

![image-20240503194927847](https://cdn.fengxianhub.top/resources-master/image-20240503194927847.png)



## 3.5 属性驱动的软件设计方法

ADD方法的核心是利用对质量属性实现与架构设计之间关系的理解，如体系结构风格、质量战术等，来进行软件架构设计。通过输入`质量属性场景`，ADD方法能够在满足这些非功能需求的基础上建立模块分解过程，从而实现架构设计，通常系统ADD方法的输出是`架构图`

## 3.5 软件架构风格

>答题技巧：
>
>- 自定义就是`解释器`
>- 语言识别系统就是`黑板系统`
>- 图形化界面就是`事件驱动/隐式调用`
>- 针对业务灵活组合这一要求，采用`解释器`架构风格最为合适
>- IDE是`数据共享` => 使用`数据仓储`风格
>
>软件架构风格描述某一特定领域中的系统组织方式和惯用模式，反映了领域中众多系统所共有的`结构和语义`两个方面的特征。

![image-20240503203106822](https://cdn.fengxianhub.top/resources-master/image-20240503203106822.png)

### 3.5.1 数据流风格

>C语言的编译过程其实就是数据流风格
>
>![img](https://cdn.fengxianhub.top/resources-master/v2-f45de959011fda57a26d5dadbe46a20a_1440w.webp)
>
>数据流风格包括：
>
>- 批处理序列：大量`整体`数据、无需用户交互
>- 管道-过滤器：`流式数据`、弱用户交互

![image-20240503210209920](https://cdn.fengxianhub.top/resources-master/image-20240503210209920.png)

### 3.5.2 调用返回风格

>有很多著名结构都是使用这种风格，例如OSI七层模型，通过分层，每层之间进行`调用/返回`

![image-20240503210636783](https://cdn.fengxianhub.top/resources-master/image-20240503210636783.png)

分层架构风格就是以此为依据

![image-20240503211149444](https://cdn.fengxianhub.top/resources-master/image-20240503211149444.png)

### 3.5.3 独立构件风格

>这种风格对应到设计模式就是`观察者模式`，spring中很多地方用到了，比如`ApplicationListener`事件机制
>
>- 构件作为可部署的单元，具有原子性，是不可拆分的

![image-20240503213652769](https://cdn.fengxianhub.top/resources-master/image-20240503213652769.png)

![image-20240503214215891](https://cdn.fengxianhub.top/resources-master/image-20240503214215891.png)

![image-20240503220232425](https://cdn.fengxianhub.top/resources-master/image-20240503220232425.png)

**例题**

![image-20250511153626927](https://cdn.fengxianhub.top/resources-master/image-20250511153626927.png)

### 3.5.4 虚拟机风格

>- 解释器风格
>- 基于规则的系统（规则系统）
>
>基于规则的系统可以将系统分为不变部分和可变部分，可以设计比如：
>
>- 某公司拟开发一个VIP管理系统，系统需要根据不同商场活动，不定期更新VIP会员的审核标准和VIP折扣系统

![image-20240503220335608](https://cdn.fengxianhub.top/resources-master/image-20240503220335608.png)

![image-20240503220436102](https://cdn.fengxianhub.top/resources-master/image-20240503220436102.png)

![image-20240503220744064](https://cdn.fengxianhub.top/resources-master/image-20240503220744064.png)

![image-20240503224609802](https://cdn.fengxianhub.top/resources-master/image-20240503224609802.png)



**例题**

![image-20250514005650457](https://cdn.fengxianhub.top/resources-master/image-20250514005650457.png)



### 3.5.5 仓库风格

>仓库风格也被称之为`以数据为中心`的风格
>
>- 数据库系统
>- 黑板系统：语音识别、知识推理
>- 超文本系统
>- 进行软件开发，公司拟开发一套针对该编程语言的集成开发环境，包括代码编辑、语法高亮、代码编译、运行调试等功能的IDE
>
>注册表、剪贴板都是仓库风格的应用
>
>在仓库风格中有两种不同的构件：`中央数据结构`说明当前状态，`独立构件`在中央数据存储上执行，仓库与外构件间的相互作用在系统中会有大的变化

![image-20240503225537874](https://cdn.fengxianhub.top/resources-master/image-20240503225537874.png)

>黑板风格

![image-20240503225158158](https://cdn.fengxianhub.top/resources-master/image-20240503225158158.png)

### 3.5.6 闭环控制结构（过程控制）

>- 家用空调自动调温器
>- 闭环结构通常适用于处理简单任务（如机器装配等)，并不适用于复杂任务

闭环架构有反馈

![image-20240503234521852](https://cdn.fengxianhub.top/resources-master/image-20240503234521852.png)

### 3.5.7 C2风格

![image-20240503235022472](https://cdn.fengxianhub.top/resources-master/image-20240503235022472.png)

**例题**

![image-20250512004414258](https://cdn.fengxianhub.top/resources-master/image-20250512004414258.png)

### 3.5.8 MDA

![image-20240504002149015](https://cdn.fengxianhub.top/resources-master/image-20240504002149015.png)

![image-20240504002245427](https://cdn.fengxianhub.top/resources-master/image-20240504002245427.png)

### 3.5.9 例题

![image-20240503235447860](https://cdn.fengxianhub.top/resources-master/image-20240503235447860.png)

![image-20240503235934469](https://cdn.fengxianhub.top/resources-master/image-20240503235934469.png)

答案：虚拟机风格、数据流风格、独立构件风格（事件驱动/隐式调用风格）、虚拟机风格、过程控制、黑板、解释器、事件驱动（隐式调用）

![image-20240504001737114](https://cdn.fengxianhub.top/resources-master/image-20240504001737114.png)



## 3.6 特定领域软件架构(DSSA)

>- DSSA通常是一个具有三个层次的系统模型，包括`领域开发环境`、`领域特定应用开发环境`和`应用执行环境`，其中应用工程师主要在领域特定应用开发环境中工作

![image-20240503200002100](https://cdn.fengxianhub.top/resources-master/image-20240503200002100.png)

![image-20240504143134757](https://cdn.fengxianhub.top/resources-master/image-20240504143134757.png)

>参加DSSA的人员可以划分为多种角色
>
>- 其中`领域分析者`的任务是控制整个领域分析过程，进行知识获取，将获取的知识组织到领域模型中；
>- `领域设计者`的任务是根据领域模型和现有系统开发出DSSA，并对DSSA的准确性和一致性进行验证。

### 3.6.1 建立过程

![image-20240504143228478](https://cdn.fengxianhub.top/resources-master/image-20240504143228478.png)

### 3.6.2 三层次模型

![image-20240504143321857](https://cdn.fengxianhub.top/resources-master/image-20240504143321857.png)

### 3.6.3 例题

![image-20240504143445541](https://cdn.fengxianhub.top/resources-master/image-20240504143445541.png)

>DSSA => 专家，分析、设计、实现人员



## 3.7 质量属性

- `可用性`比如100个小时里面有97个小时可用，可用性就是97%

- `可靠性`是连续的不出故障时间，故障修复时间维度进行衡量

![image-20240504150325922](https://cdn.fengxianhub.top/resources-master/image-20240504150325922.png)

### 3.7.1 性能

![image-20240504150625482](https://cdn.fengxianhub.top/resources-master/image-20240504150625482.png)

### 3.7.2 可用性

>可用性战术里面最重要的是`心跳`和`冗余`

![image-20240504151614202](https://cdn.fengxianhub.top/resources-master/image-20240504151614202.png)

### 3.7.3 安全性

>这里授权可用不是可用性，重点在授权，所以是`安全性`

![image-20240504152124211](https://cdn.fengxianhub.top/resources-master/image-20240504152124211.png)

### 3.7.4 可修改性

![image-20240504152436424](https://cdn.fengxianhub.top/resources-master/image-20240504152436424.png)

### 3.7.5 易用性&可测试性

>`记录-回放`主要提高系统的可测试性

![image-20240504153721833](https://cdn.fengxianhub.top/resources-master/image-20240504153721833.png)

### 3.7.6 质量效用树

![image-20240504160612453](https://cdn.fengxianhub.top/resources-master/image-20240504160612453.png)

### 3.7.7 例题

![image-20240504154755382](https://cdn.fengxianhub.top/resources-master/image-20240504154755382.png)

![image-20240504154945188](https://cdn.fengxianhub.top/resources-master/image-20240504154945188.png)

## 3.8 软件架构评估

>敏感点是指为了实现某种特定的质量属性，一个或多个系统组件所具有的特性

![image-20240504155708811](https://cdn.fengxianhub.top/resources-master/image-20240504155708811.png)

1. 反过来看，协议和设计是交易请求的特征，所以是敏感点
2. 非风险点（句式：xxx要求是可以实现的）
3. 风险点
4. 权衡点

### 3.8.1 架构评估方法

![image-20240504161718187](https://cdn.fengxianhub.top/resources-master/image-20240504161718187.png)

>场景核心就是三个方面：刺激、响应、环境

![image-20240504162112052](https://cdn.fengxianhub.top/resources-master/image-20240504162112052.png)

### 3.8.2 基于场景的评估方法

![image-20240504162711781](https://cdn.fengxianhub.top/resources-master/image-20240504162711781.png)

#### 3.8.2.1 SAAM

Software Architecture Analysis Method

![image-20240504163734054](https://cdn.fengxianhub.top/resources-master/image-20240504163734054.png)

#### 3.8.2.2 ATAM

Architecture Tradeoff Analysis Method

>收集、实现、分析和折中

![image-20240504163919587](https://cdn.fengxianhub.top/resources-master/image-20240504163919587.png)

**案例题作答**

![image-20250517180957857](https://cdn.fengxianhub.top/resources-master/image-20250517180957857.png)



### 3.8.3 例题

![image-20240504164057322](https://cdn.fengxianhub.top/resources-master/image-20240504164057322.png)



![image-20240504165832331](https://cdn.fengxianhub.top/resources-master/image-20240504165832331.png)

![image-20240504170106057](https://cdn.fengxianhub.top/resources-master/image-20240504170106057.png)



## 3.9 软件产品线

软件产品线的思想是在一个领域做的有共性的东西应该保留下来，下次直接进行使用

![image-20240504190328713](https://cdn.fengxianhub.top/resources-master/image-20240504190328713.png)

### 3.9.1 双生命周期模型

在双生命周期模型中，分为`核心组`和`应用组`，核心组负责共性功能的建设，应用组负责业务开发和系统实现

![image-20240504233208590](https://cdn.fengxianhub.top/resources-master/image-20240504233208590.png)

### 3.9.2 建立方式

![image-20240504233920968](https://cdn.fengxianhub.top/resources-master/image-20240504233920968.png)

### 3.9.3 组织结构

![image-20240504234009655](https://cdn.fengxianhub.top/resources-master/image-20240504234009655.png)

## 3.10 构件和中间件

![image-20240505144152685](https://cdn.fengxianhub.top/resources-master/image-20240505144152685.png)

![image-20240505144231651](https://cdn.fengxianhub.top/resources-master/image-20240505144231651.png)

>中间件的概念

![image-20240505144716042](https://cdn.fengxianhub.top/resources-master/image-20240505144716042.png)

![image-20240505144738312](https://cdn.fengxianhub.top/resources-master/image-20240505144738312.png)

### 3.10.1 软件复用

>主要点是`水平重用`和`垂直重用`
>
>软件复用过程包含:创建、复用、支持、管理4个过程。
>
>1、创建过程:界定和提供可复用资产，以满足复用者的需要;
>
>2、复用过程:利用可复用资产来生产应用软件产品
>
>3、支持过程:全面支持可复用资产的获取、管理和维护工作;
>
>4、管理过程:执行计划、启动、资源、跟踪，并协调其他各个过程;

![image-20240505004819753](https://cdn.fengxianhub.top/resources-master/image-20240505004819753.png)



![image-20240505004935859](https://cdn.fengxianhub.top/resources-master/image-20240505004935859.png)

![image-20240505005022075](https://cdn.fengxianhub.top/resources-master/image-20240505005022075.png)

![image-20240505005034874](https://cdn.fengxianhub.top/resources-master/image-20240505005034874.png)

![image-20240505010208033](https://cdn.fengxianhub.top/resources-master/image-20240505010208033.png)

### 3.10.2 构件的复用

![image-20240505141816929](https://cdn.fengxianhub.top/resources-master/image-20240505141816929.png)

### 3.10.3 例题

![image-20240505141957479](https://cdn.fengxianhub.top/resources-master/image-20240505141957479.png)

![image-20240505142035146](https://cdn.fengxianhub.top/resources-master/image-20240505142035146.png)

### 3.10.4 中间件

![image-20240505144903311](https://cdn.fengxianhub.top/resources-master/image-20240505144903311.png)

### 3.10.5 构建标准

![image-20240505145312476](https://cdn.fengxianhub.top/resources-master/image-20240505145312476.png)

### 3.10.6 CORBA

![image-20240505145339969](https://cdn.fengxianhub.top/resources-master/image-20240505145339969.png)

## 3.11 经典架构应用

经典的架构设计有很多

### 3.11.1 层次架构

层次架构是最通用的架构，常作为初始架构，`关注分离`每层只负责本层的工作

常见的层次架构有：

- MVC
- MVP
- MVVM

## 3.12 大型网站架构演化

### 3.12.1 维度

![image-20240505150310726](https://cdn.fengxianhub.top/resources-master/image-20240505150310726.png)

### 3.12.2 演化过程

 	1. 单体架构
 	2. 垂直架构
 	3. 使用缓存
 	4. 集群模式
 	5. 数据库读写分离
 	6. 使用反向代理和CDN加速
 	7. 使用分布式文件系统和分布式数据库系统
 	8. 使用NoSQL和搜索引擎
 	9. 业务拆分
 	10. 分布式服务

## 3.13 其他

### 3.13.1 软件架构复用

软件架构复用的类型包括`机会复用`和`系统复用`

- 机会复用是指开发过程中，只要发现有可复用的资产，就对其进行复用
- 系统复用是指在开发之前，就要进行规划，以决定哪些需要复用

## 4. 应用数学&计算题

这一段要考的内容并不是太多，主要是图论、动态规划、决策分析、不确定性分析、线性规划这几方面内容。

### 4.1 **克鲁斯卡尔算法**

克鲁斯卡尔算法是一种用于解决最小生成树问题的贪心算法。它的目标是连接图中所有节点，且使得总边权重最小，并且不形成回路

>简单步骤如下：
>
>1. 边排序：将图中所有边按权重从小到大排序。
>2. 选择边：从权重最小的边开始，逐步加入生成树中，但要确保加入的边不形成回路。
>3. 重复步骤2，直到选出恰好n-1条边（对于n个节点的连通图）。
>
>最终得到的生成树既包含所有节点，又具有最小的总边权重。

![image-20241109194508354](https://cdn.fengxianhub.top/resources-master/image-20241109194508354.png)



### 4.2 最大流量问题

>这是个线性规划问题，基本上就是下面这种运输、流量问题

![image-20241109194548411](https://cdn.fengxianhub.top/resources-master/image-20241109194548411.png)

首先第一步是把成本都标上

从1到6有多条路径，`总的最大运量应等于每条路径上的最大运量之和`
每条路径上有多段，每条路径上的最大运量应是各路段最大运量的`最小值。`
多条路径可以共享同一路段，该路段上的流量等于所有各条路径上的流量之和。

![image-20241109202717145](https://cdn.fengxianhub.top/resources-master/image-20241109202717145.png)



### 4.3 决策分析

![image-20241109203022057](https://cdn.fengxianhub.top/resources-master/image-20241109203022057.png)

>画出决策树 然后求和



### 4.4 指派问题

![image-20241109205652625](https://cdn.fengxianhub.top/resources-master/image-20241109205652625.png)

>这种问题就是矩阵求

![image-20241109205711547](https://cdn.fengxianhub.top/resources-master/image-20241109205711547.png)

### 4.5 CRC校验码

>例题：若信息码字为111000110，生成多项式G(x)=x5+x3+x+1，则计算出的CRC校验码为（ ）。

![image-20251018135354535](https://cdn.fengxianhub.top/resources-master/image-20251018135354535.png)

### 4.5 流水线相关

### 4.6 位示图



## 5. 操作系统

```shell
【操作系统 - 存储管理】
├── **1. 核心目标**
│   ├── 地址重定位：将逻辑地址（相对地址）转换为物理地址（绝对地址）
│   ├── 分配与回收：高效管理内存空间
│   ├── 存储保护：保证各进程互不干扰
│   └── 内存扩充：通过虚拟内存技术实现
│
├── **2. 连续分配管理方式** （为进程分配一块连续的内存空间）
│   ├── 单一连续分配：无外部碎片，用于单道程序系统
│   ├── 固定分区分配：产生内部碎片
│   └── 动态分区分配：产生外部碎片
│       ├── 分配算法：
│       │   ├── 首次适应法 (First Fit)：从低地址开始找第一个够用的分区
│       │   ├── 最佳适应法 (Best Fit)：找大小最接近需求的分区（易产生小碎片）
│       │   ├── 最坏适应法 (Worst Fit)：找最大的分区进行分配
│       │   └── 循环首次适应法 (Next Fit)：从上次结束的位置开始找
│       └── 碎片处理：紧凑技术（耗时）
│
└── **3. 非连续分配管理方式** （进程可以分散在不相邻的内存空间中）
    ├── **3.1 分页式存储管理 (Paging)**
    │   ├── 核心思想：
    │   │   ├── 物理内存：划分为固定大小的【页框/块】
    │   │   ├── 逻辑内存：划分为固定大小的【页/页面】
    │   │   └── 页与页框大小相同
    │   │
    │   ├── 数据结构：【页表】
    │   │   ├── 作用：记录逻辑页号与物理页框号的映射关系
    │   │   └── 每个进程拥有一张自己的页表
    │   │
    │   ├── 地址转换（软考重点！）
    │   │   ├── 逻辑地址 = 【页号P】+ 【页内偏移量W】
    │   │   ├── 物理地址 = 【页框号】× 页大小 + 【页内偏移量W】
    │   │   └── 过程：CPU取指令 -> 提取页号 -> 查页表 -> 得页框号 -> 合成物理地址 -> 访问内存
    │   │
    │   ├── 管理方式（空闲内存管理）
    │   │   ├── 位图法 (Bitmap)：用0/1表示页框是否空闲（本题考点）
    │   │   └── 链表法：将空闲页框链接起来
    │   │
    │   ├── 快表 (TLB - Translation Lookaside Buffer)
    │   │   ├── 作用：缓存部分页表项，加速地址转换
    │   │   └── 原理：基于程序访问的局部性原理
    │   │
    │   └── 优缺点：
    │       ├── 优：无外部碎片，内存利用率高
    │       └── 缺：存在内部碎片；需硬件支持，管理开销大
    │
    ├── **3.2 分段式存储管理 (Segmentation)**
    │   ├── 核心思想：
    │   │   ├── 按程序的逻辑结构（如主程序、子程序、数据段）划分段
    │   │   ├── 段长可变
    │   │   └── 逻辑地址 = 【段号S】+ 【段内偏移量W】
    │   │
    │   ├── 数据结构：【段表】
    │   │   ├── 作用：记录段号与段基址、段长的映射关系
    │   │   └── 包含：段基址、段长（用于越界检查）
    │   │
    │   ├── 地址转换：
    │   │   ├── 根据段号S查段表，得到该段在内存中的起始地址（基址）
    │   │   ├── 检查段内偏移W是否小于段长，防止越界
    │   │   └── 物理地址 = 【基址】 + 【段内偏移量W】
    │   │
    │   └── 优缺点：
    │       ├── 优：便于信息共享和保护（以段为单位），符合用户视角
    │       └── 缺：产生外部碎片；地址转换比分页复杂
    │
    └── **3.3 段页式存储管理 (Segmented Paging) - 软考高频！**
        ├── 核心思想：结合分段和分页的优点
        │   ├── 先将程序按逻辑分段
        │   └── 再将每个段进行分页
        │
        ├── 地址转换（两级寻址）
        │   ├── 逻辑地址 = 【段号S】+ 【页号P】+ 【页内偏移量W】
        │   ├── 过程：
        │   │   1. 根据【段号S】查【段表】，找到该段对应的【页表起始地址】
        │   │   2. 根据【页号P】查【页表】，找到对应的【物理页框号】
        │   │   3. 物理地址 = 【页框号】× 页大小 + 【W】
        │   │
        │   └── 需要两次查表（段表、页表），效率问题通常通过快表(TLB)解决
        │
        └── 优缺点：
            ├── 优：结合两者优点，便于共享和保护，无外部碎片
            └── 缺：地址转换过程复杂，开销大

```

### 5.1 进程存储

#### 5.1.1 内存分配算法

 一、`首次适应算法（First Fit）`：该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链    中。

 特点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。

 缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。

   二、`最佳适应算法（Best Fit）`：该算法总是把既能满足要求，又是最小的空闲分区分配给作业。为了加速查找，该算法要求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。

 特点：每次分配给文件的都是最合适该文件大小的分区。

 缺点：内存中留下许多难以利用的小的空闲区。

  三、`最坏适应算法（Worst Fit）`:最坏适应算法是将输入的作业放置到主存中与它所需大小差距最大的空闲区中。空闲区大小由大到小排序。

  特点：尽可能地利用存储器中大的空闲区。

  缺点：绝大多数时候都会造成资源的严重浪费甚至是完全无法实现分配。

四、循环首次适应法

#### 5.1.2 页式存储管理

>高级语言在设计时使用逻辑地址，但在运行时需要用物理地址在内存中寻找，这就涉及**逻辑逻辑地址和物理地址的转换**
>
>**页式存储**是把计算机的存储器划分成**大小相等**的多个区域，每个区域称为一块，并对它们按照顺序编号。
>
>`物理地址 = 块号 X 块长 + 页内地址`

**页式存储优点**

![image-20251018002049318](https://cdn.fengxianhub.top/resources-master/image-20251018002049318.png)

**页式存储缺点**

![image-20251018002531170](https://cdn.fengxianhub.top/resources-master/image-20251018002531170.png)

总结

![image-20251018002857061](https://cdn.fengxianhub.top/resources-master/image-20251018002857061.png)

**例题**

![image-20251016233621231](https://cdn.fengxianhub.top/resources-master/image-20251016233621231.png)

例题

![image-20251017213104105](https://cdn.fengxianhub.top/resources-master/image-20251017213104105.png)

4k=2^12次方，也就是后12位是内存中的物理地址，高于12位的就是页号

我们看到逻辑地址是5A29H，一个16进制位，需要用4个二进制位存储，所以后面的【A29】不用动，可以推出页内地址，也就是物理地址就是A29

接下来算页号，逻辑地址第一位是5，查询页表可以看出，物理块号（页帧号）是6

淘汰页面需要该页在内存中，并且不能淘汰刚被访问的页，所以淘汰页1

#### 5.1.3 段式存储管理

![image-20251018001607598](https://cdn.fengxianhub.top/resources-master/image-20251018001607598.png)

段式存储跟页式存储的最大区别在于，内存分割的方式跟页式不一样，段式存储是按照逻辑结构进行划分的，比如段式存储可以将一个函数完整的栈存放在一起，避免多次查找，这样一个段的大小并不固定，可能是40k，也可能是150k。

#### 5.1.4 段页式存储管理

>简单来说，段式存储管理是将页式存储组织的**页大小设置为不固定**。
>
>因为程序一般都是由主程序、子程序、堆栈等元素组成，每一段都有自己独立的作用，我们不能去断章取义，所以**将一段作为单位存储在内存中**，也是一种很好的方式，这就是**段式存储**。
>
>每个作业都由独立段组成，可以给段做个编号，即逻辑地址从 0 开始编号。
>
>段内地址是连续的，段和段之间的地址是不连续的，**段式存储的逻辑地址由段号和段内地址**组成，如下所示。

![image-20251018003719786](https://cdn.fengxianhub.top/resources-master/image-20251018003719786.png)

#### 5.1.5 快表

![image-20251018003819985](https://cdn.fengxianhub.top/resources-master/image-20251018003819985.png)

### 5.2 CPU

#### 5.2.1 cpu组成

![CPU组成](https://cdn.fengxianhub.top/resources-master/689056-20211213001833220-675196650.png)

>CPU由如下四个部分(寄存器、CU、ALU、中断系统)组成：
>
>**1. 寄存器 - 总经理的即时贴和桌面文件框**
>
>- **定位**：CPU**内部**的、容量极小但速度极快的存储单元。
>- **功能**：用于暂时存放当前正在执行的指令、数据或地址。就像总经理桌上放着的**即时贴和正在处理的文件**，随手就能拿到，速度极快。
>- **特点**：容量小，速度快，成本高。是CPU能直接、最快访问的存储空间。
>
>------
>
>**2. CU - 总经理本人**
>
>- **定位**：**控制单元**，是CPU的**指挥中心**和**大脑**。
>- **功能**：
>  - **取指令**：命令从内存中取出下一条要执行的指令。
>  - **分析指令**：解读这条指令是什么意思（比如，是加法还是读取数据？）。
>  - **发号施令**：根据指令的含义，向CPU的其他所有部件（ALU、寄存器等）发出具体的**控制信号**，协调它们步调一致地完成工作。
>- **简单说**：**CU不负责具体计算，只负责指挥和协调。**
>
>------
>
>**3. ALU - 总经理手下的精算师团队**
>
>- **定位**：**算术逻辑单元**，是CPU的**计算核心**。
>- **功能**：
>  - **算术运算**：执行加、减、乘、除等数学运算。
>  - **逻辑运算**：执行与、或、非、异或等逻辑判断。
>  - **移位操作**：执行二进制位的左移、右移等操作。
>- **简单说**：**ALU只负责“算”和“比”，但算什么、比什么，要听CU的指挥。**
>
>------
>
>**4. 中断系统 - 总经理的紧急事务秘书**
>
>- **定位**：处理**突发紧急事件**的机制。
>- **功能**：
>  - 当有**更高优先级的事件**发生（比如用户敲了一下键盘、来了一个网络数据包，或者程序出现错误），中断系统会**向CU报告**。
>  - CU会**暂停**当前正在执行的常规工作，**保存现场**，然后先去处理这个紧急事件。
>  - 处理完后，再**恢复现场**，继续刚才被中断的工作。
>- **简单说**：**让CPU具备“响应突发事件”的能力，不用一直傻等着。**
>
>
>
>**总结与工作流程比喻**
>
>现在，我们看一个简单的工作流程，看它们如何协作：
>
>**任务：计算 1 + 2**
>
>1. **CU** 指挥，从内存把指令 `“加法”` 和数据 `“1”`, `“2”` 取到**寄存器**中。
>2. **CU** 向 **ALU** 发出命令：“执行加法运算！”
>3. **ALU** 从**寄存器**中取出数字1和2，进行计算，得到结果3。
>4. **ALU** 将结果3存回**寄存器**。
>5. **（突然，用户按了键盘）中断系统** 通知 **CU**：“有紧急输入事件！”
>6. **CU** 立刻保存当前的加法工作现场，转去处理键盘输入。处理完后，再回来继续后续工作。
>
>**一句话总结：**
>
>- **CU**是大脑，负责**指挥**。
>- **ALU**是双手，负责**计算**。
>- **寄存器**是工作台，负责**暂存**。
>- **中断系统**是警报器，负责**应急**。

#### 5.2.2 cpu频率组成

CPU的工作频率（主频）包括两个部分：外频与倍频，两者的乘积就是主频。
所谓外频，就是外部频率，指的是系统总线频率。
倍频的全称是倍频系数，倍频系数是指CPU主频与外频之间的相对比例关系。最初CPU主频和系统总线速度是一样的，但CPU的速度越来越快，倍频系数也就相应产生。它的作用是使系统总线工作在相对较低的频率上，而CPU速度可以通过倍频来提升。

例题：CPU的频率有主频、倍频和外频。某处理器外频是200MHz，倍频是13，该款处理器的主频是（ ）。

结论：200MHz * 13 = 2.6GHz

#### 5.2.3 读取速度对比

![image-20251018222502513](https://cdn.fengxianhub.top/resources-master/image-20251018222502513.png)

#### 5.3 哈佛结构和冯诺依曼结构

>二者的区别就是程序空间和数据空间是否是一体的。冯·诺依曼结构数据空间和地址空间不分开，哈佛结构数据空间和地址空间是分开的。
>
>哈佛总线技术应用是以DSP和[ARM](https://zhida.zhihu.com/search?content_id=107206687&content_type=Article&match_order=1&q=ARM&zhida_source=entity)为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指和取操作数，从而大大提高了运算能力。
>
>1. **经典的ARM内核（如ARM7）采用的是冯·诺依曼架构**，而不是哈佛架构。它的程序和数据共享同一个存储空间和总线。
>2. **现代的高性能ARM处理器（如Cortex-A系列，也就是手机里用的）采用的是“改进型哈佛架构”**。

| 芯片类型                       | **典型架构**           | **解释**                                                     |
| :----------------------------- | :--------------------- | :----------------------------------------------------------- |
| **DSP**                        | **（改进型）哈佛架构** | **从一而终的坚持者**。为了极致的信号处理效率，在体系结构层面就采用独立的程序/数据总线。 |
| **经典/低端ARM**               | **冯·诺依曼架构**      | 追求低成本、低功耗，设计简单。                               |
| **现代高性能ARM（如手机SoC）** | **改进型哈佛架构**     | **灵活的实用主义者**。通过在CPU核心内部使用分离的指令/数据缓存来获得哈佛架构的并行性能优势，同时在外部保持系统的统一和简洁。 |

#### 5.3 CISC&RISC

![image-20251019010717250](https://cdn.fengxianhub.top/resources-master/image-20251019010717250.png)



### 5.3 存储介质

| 存储类型                 | **断电后数据** | **典型用途**                     | **通俗比喻**                   |
| :----------------------- | :------------- | :------------------------------- | :----------------------------- |
| **SRAM / DRAM / 寄存器** | **丢失**       | 内存条、CPU缓存                  | **粉笔字（需持续供电维持）**   |
| **Flash闪存**            | **不丢失**     | U盘、SSD固态硬盘、手机存储、SD卡 | **钢笔字（写在纸上永久保存）** |
| **硬盘(HDD)**            | **不丢失**     | 电脑硬盘                         | **刻在石碑上（机械永久）**     |

### 5.4 存储器

**四种存取方式与对应存储器详解**

| 存取方式        | **核心原理**                                                 | **访问时间特征**                                             | **典型代表**                        | **通俗比喻**                                                 |
| :-------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | :----------------------------------------------------------- |
| **1. 顺序存取** | 数据按顺序排成记录。要访问某个数据，必须从头开始顺序经过前面的所有数据。 | **可变**。访问时间取决于数据的位置。                         | **磁带**                            | **录音带/录像带**：想听第5首歌，必须快进过前4首。            |
| **2. 直接存取** | 数据被组织在具有唯一地址的块中（如扇区）。存取机制直接指向数据所在的大致区域，然后在该区域内进行顺序搜索。 | **半可变**。包含“寻道”（定位区域）和“等待”（在区域内查找）两个阶段。 | **磁盘（硬盘、光盘）**              | **CD/DVD光盘**：激光头可以直接移动到某个音轨的大致位置，然后稍微旋转一下找到精确起点。 |
| **3. 随机存取** | 每个可寻址单元（如字节/字）都有唯一的、可直接寻址的物理地址。访问任何单元的时间相同，与单元的位置无关。 | **固定/恒定**。这是最快和最直接的方式。                      | **主存储器（内存）** **DRAM, SRAM** | **一栋公寓楼的门牌号**：你可以根据门牌号（内存地址）直接、快速地找到任意一户，不需要经过其他住户。 |
| **4. 相联存取** | **按内容访问**。不是通过地址，而是通过数据的部分内容（关键字）来检索。存储器会同时比较所有存储单元的关键字，返回匹配的单元。 | **固定**。比较过程是并行进行的，所以时间恒定。               | **高速缓存（Cache）** 、**TLB**     |                                                              |



### 5.5 RAID

>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。
>
>- https://zhuanlan.zhihu.com/p/51170719

RAID方案常见的可以分为：

- RAID0
- RAID1
- RAID3
- RAID5
- RAID6
- RAID10

容量计算：

| RAID 级别   | **最少磁盘** | **容错能力**      | **可用容量** | **读性能**    | **写性能**            | **主要应用场景**                                        |
| :---------- | :----------- | :---------------- | :----------- | :------------ | :-------------------- | :------------------------------------------------------ |
| **RAID 0**  | 2            | **无**            | n × S        | **极高**      | **极高**              | 追求极致性能、不关心数据安全的场景，如视频剪辑缓存。    |
| **RAID 1**  | 2            | **优 (n-1)**      | (n/2) × S    | 高 (可并发读) | 中等                  | 对数据安全性要求极高的场景，如操作系统、数据库日志。    |
| **RAID 5**  | 3            | **良 (1块)**      | (n - 1) × S  | 高            | 中等 (需计算奇偶校验) | 兼顾性能、容量和安全的通用选择，如文件存储、Web服务器。 |
| **RAID 6**  | 4            | **优 (2块)**      | (n - 2) × S  | 高            | 较低 (需计算双重校验) | 对数据安全要求**极高**的场景，如大型归档、金融数据。    |
| **RAID 10** | 4            | **优 (同组不坏)** | (n/2) × S    | **极高**      | **高**                |                                                         |

### 5.6 寄存器

| 寄存器            | **英文全称**             | **主要功能**                                  | **特点**                                                     | **通俗比喻**                                                 |
| :---------------- | :----------------------- | :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **A. 程序计数器** | **Program Counter**      | 存放下一条要执行的指令的**内存地址**。        | 1. **CPU的指南针**，决定程序流向。 2. 内容会自动递增，或随跳转指令改变。 | **总经理的日程表**：指明下一步要处理哪项工作。               |
| **B. 指令寄存器** | **Instruction Register** | 存放**当前正在执行**的指令。                  | 1. **指令的临时工作台**。 2. 其内容被送到**控制单元**进行解码。 | **总经理正在阅读的当前工作文件**：文件正摊在桌上处理。       |
| **C. 状态寄存器** | **Status Register**      | 存放CPU**最近一次操作**的结果状态（标志位）。 | 1. 包含**零标志、进位标志、溢出标志**等。 2. 为条件跳转指令（如if判断）提供依据。 | **办公室的警报灯和状态屏**：显示上一个操作是否成功、是否有异常等。 |
| **D. 通用寄存器** | **General Register**     | 存放**临时数据**，如操作数、中间结果、地址。  | 1. **数量最多、最灵活**的寄存器。 2. 是CPU进行计算的**主战场**。 | **总经理桌上的便签本和计算器**：用来临时记录数据、进行草稿计算。 |

### **总结与记忆技巧**

- **PC**：管 **“下一步去哪”**（地址）。
- **IR**：管 **“现在干啥”**（指令）。
- **SR**：管 **“刚才干的咋样”**（状态）。
- **GR**：管 **“用什么来干”**（数据）。

这四种寄存器各司其职，紧密配合，共同完成了CPU最基础的指令执行周期（取指 -> 译码 -> 执行）。

在CPU工作的核心周期（冯·诺依曼体系结构的核心）。我们来看一下这三个阶段分别用到了哪些寄存器。

| 阶段     | **核心任务** | **主要使用的寄存器**           |
| :------- | :----------- | :----------------------------- |
| **取指** | 从内存取指令 | **程序计数器**、**指令寄存器** |
| **译码** | 解析指令含义 | **指令寄存器**                 |
| **执行** | 执行指令操作 | **通用寄存器**、**状态寄存器** |

```Mermaid
flowchart TD
    A[CPU指令执行周期] --> B["① 取指阶段<br>PC -> MAR -> 内存"]
    B --> C["指令 -> MBR -> IR"]
    C --> D["② 译码阶段<br>CU 译码 IR 内容"]
    D --> E["③ 执行阶段"]
    E --> F["操作数来自 GR<br>结果存回 GR<br>ALU 设置 SR"]
    
    B --> G["PC + 1 -> PC"]
    G --> D
    
    subgraph RegisterUsage [核心寄存器使用]
        H[程序计数器<br>PC]
        I[指令寄存器<br>IR]
        J[通用寄存器<br>GR]
        K[状态寄存器<br>SR]
    end
    
    H -.-> B
    I -.-> C
    I -.-> D
    J -.-> F
    K -.-> F
```



## 6. 数据库相关

### 6.1 三级模式两级映射

![image-20251018215659956](https://cdn.fengxianhub.top/resources-master/image-20251018215659956.png)

- 外模式对应用户级，可以利用[数据操纵语言](https://baike.baidu.com/item/数据操纵语言)(Data Manipulation Language，`DML`) 对这些数据记录进行操作
- 概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，`DDL`)来描述、定义的。
  - 对应表这一级，通过该模式，可以方便方便修改用户看到表的字段，比如不想用户能直接看到password这个字段
- 内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。

**例题**

采用三级模式结构的数据库系统中，如果对一个表创建聚簇索引，那么改变的是数据库的（ ）。

改变的是内模式

### 6.2 ACID

| 特性                   | 中文       | 核心含义                                                     | **实现原理（核心技术）**                                     | 通俗比喻                                                     |
| :--------------------- | :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **A**tomicity 原子性   | **原子性** | 事务是一个不可分割的工作单位。事务中的所有操作，要么全部成功，要么全部失败回滚。 | **1. Undo Log（回滚日志）**： - 在事务修改任何数据**之前**，先将数据的原始版本拷贝到 Undo Log 中。 - 如果事务失败或需要回滚，系统可以利用 Undo Log 将数据恢复到事务开始前的状态。 **2. 事务管理器**：负责协调事务的提交或回滚。 | **要么全部发货，要么取消订单**：网购下单后，要么你成功付款、商家发货、你收货；要么任何一个环节失败，你的付款会被退回，就像什么都没发生过。 |
| **C**onsistency 一致性 | **一致性** | 事务必须使数据库从一个**一致性状态**转变到另一个**一致性状态**。即数据必须满足预定义的完整性约束。 | **1. 应用程序和数据库共同保证**： - **数据库层面**：通过**主键、外键、唯一约束、数据类型、CHECK约束**等来保证。 - **应用层面**：业务逻辑要正确，写入的数据必须有意义。 **2. 原子性、隔离性、持久性是实现一致性的工具**。 | **遵守游戏规则**：转账前后，A和B的账户总额必须保持不变。这个“总额不变”就是一致性规则，由原子性（必须同时完成转出和转入）等来保证。 |
| **I**solation 隔离性   | **隔离性** | 并发执行的各个事务之间不能互相干扰。一个事务的内部操作与其他并发事务是隔离的。 | **1. 锁机制**： - **悲观锁**：在操作数据前先加锁，阻止其他事务访问。 - **行锁、表锁、间隙锁**等。 **2. 多版本并发控制**： - **MVCC**：为数据创建多个版本。一个事务在开始时，只能看到在它开始之前已经提交的数据版本，从而避免读写冲突。这是提高并发性能的关键技术。 **3. 事务隔离级别**： - 通过设置不同的隔离级别，在并发性能和数据一致性之间进行权衡。 | **流水线作业**：多个厨师在同一个厨房工作，但各自有自己独立的工作台和食材区，互不干扰（隔离性）。他们通过一个公共的菜单板来协调顺序。 |
| **D**urability 持久性  | **持久性** | 一旦事务提交，它对数据库的修改就是永久性的，即使发生系统故障也不会丢失。 | **1. Redo Log（重做日志）**： - 在事务修改任何数据**之后**，但数据页尚未刷回磁盘之前，先将修改内容写入 Redo Log。 - **Write-Ahead Logging**：日志必须先于数据页被写入磁盘。 - 当系统崩溃重启后，即使数据页丢失，也可以通过 Redo Log 重新执行所有已提交的事务，从而恢复数据。 **2. 事务提交时，必须确保 Redo Log 已写入磁盘。** | **保险箱和记事本**：你把钱放进保险箱（数据页），但在此之前，你会先把“存入XX元”这件事写在一個永不丢失的记事本（Redo Log）上。即使保险箱被炸毁，你也能根据记事本恢复你的财产记录。 |

**核心机制总结**

1. **Undo Log → 实现 原子性**：用于回滚，保证“要么全做，要么全不做”。
2. **Redo Log → 实现 持久性**：用于故障恢复，保证“做了就不丢”。
3. **锁 + MVCC → 实现 隔离性**：用于控制并发，保证“互不干扰”。
4. **以上三者共同 → 保障 一致性**：使得数据库总能处于一个正确的逻辑状态。

这个表格清晰地展示了 ACID 特性不仅是理论概念，更是由一系列精妙的工程技术（尤其是日志机制）所支撑的。

### 6.3 隔离性

>隔离性是指并发事务之间相互隔离，不能互相干扰。但“干扰”到什么程度，有不同的标准。为了量化这些标
>
>准，ANSI SQL标准定义了不同的事务隔离级别，每个级别会排除特定的并发副作用。
>
>**Mysql InnoDB**默认隔离级别是RR，也就是可重复读，不满足最高级别的隔离性（串行化），它允许幻读的发生（注：InnoDB通过`间隙锁`技术在很大程度上防止了幻读，但并非在所有场景下都能完全避免，这与纯理论定义有细微差别）

### 6.4 **并发副作用（从轻到重）**

- **脏读**：事务A读到了事务B**未提交**的数据。
- **不可重复读**：在同一个事务A中，两次读取**同一条**记录，得到了不同的结果（因为在这两次读取之间，该记录被另一个已提交的事务B修改了）。
- **幻读**：在同一个事务A中，两次执行**相同的查询**，得到了不同的记录集（因为在这两次查询之间，另一个已提交的事务B**插入或删除**了满足查询条件的记录）。

其中**不可重复读**和**幻读**非常相似，区别在于，**操作的对象不同**

- **不可重复读**：针对的是 **“同一行记录”** 的值被修改。
- **幻读**：针对的是 **“满足条件的记录集”** 中，有新的行被插入或删除。

| 特性               | **不可重复读**                 | **幻读**                                           |
| :----------------- | :----------------------------- | :------------------------------------------------- |
| **操作对象**       | **同一行记录**                 | **同一个查询条件的结果集**                         |
| **焦点**           | 记录的**值/内容**发生变化      | 结果集的**行数/范围**发生变化                      |
| **其他事务的操作** | **UPDATE**（更新）             | **INSERT**（插入）或 **DELETE**（删除）            |
| **问题本质**       | “我盯着的这个人，他怎么变了？” | “我查的这个范围，怎么突然多出来（或少了一个）人？” |
| **解决方法**       | **行锁**                       | **范围锁（如间隙锁、Next-Key锁）**                 |

各种隔离级别下允许发生的副作用如下

| 隔离级别                          | 脏读       | 不可重复读 | 幻读       | **默认采用的数据信**               |
| :-------------------------------- | :--------- | :--------- | :--------- | :--------------------------------- |
| **READ UNCOMMITTED** （读未提交） | **允许**   | **允许**   | **允许**   |                                    |
| **READ COMMITTED** （读已提交）   | **不允许** | **允许**   | **允许**   | **Oracle, PostgreSQL, SQL Server** |
| **REPEATABLE READ** （可重复读）  | **不允许** | **不允许** | **允许**   | **MySQL InnoDB**                   |
| **SERIALIZABLE** （串行化）       | **不允许** | **不允许** | **不允许** |                                    |

### 6.5 数据库完整性

>**数据库完整性**是指数据库中数据的**准确性**和**一致性**。它通过施加一系列约束规则，来防止数据库中存在不符合语义、不精确或无效的数据。
>
>数据库管理系统通过强制实施这些完整性约束，在数据被插入、更新或删除时自动进行检查，从而在源头上保障了数据的质量，使得数据库成为一个可靠的信息来源。

```Mermaid
flowchart TD
    A[数据库完整性] --> A1[实体完整性]
    A --> A2[参照完整性]
    A --> A3[用户定义完整性]

    A1 --> A1_1[主键非空且唯一]
    A1 --> A1_2[标识每条记录]

    A2 --> A2_1[外键必须匹配主键]
    A2 --> A2_2[保证表间关系正确]

    A3 --> A3_1[域完整性]
    A3 --> A3_2[业务规则完整性]
    
    A3_1 --> C1[数据类型]
    A3_1 --> C2[取值范围<br>非空约束等]
    
    A3_2 --> D1[唯一约束]
    A3_2 --> D2[检查约束<br>等]
```

对比如下

| 完整性类型         | **核心思想**               | **约束对象** | **主要实现**                                       |
| :----------------- | :------------------------- | :----------- | :------------------------------------------------- |
| **实体完整性**     | 我是谁？（唯一标识）       | **主键**     | `PRIMARY KEY`                                      |
| **参照完整性**     | 我属于谁？（有效引用）     | **外键**     | `FOREIGN KEY`                                      |
| **用户定义完整性** | 我是什么样的？（业务规则） | **字段/列**  | `NOT NULL`, `UNIQUE`, `CHECK`, `DEFAULT`, 触发器等 |

### 6.5 范式

| 范式     | 中文            | 要求                                                         | 解决什么问题                                   |
| :------- | :-------------- | :----------------------------------------------------------- | :--------------------------------------------- |
| **1NF**  | 第一范式        | 属性原子性（不可再分）                                       | 消除重复组                                     |
| **2NF**  | 第二范式        | 在 1NF 基础上，**非主属性完全依赖于候选键**（消除部分依赖）  | 减少数据冗余，避免更新异常（对复合主键时检查） |
| **3NF**  | 第三范式        | 在 2NF 基础上，**非主属性不传递依赖于候选键**（消除传递依赖） | 进一步减少冗余和异常                           |
| **BCNF** | Boyce-Codd 范式 | 在 3NF 基础上，**所有函数依赖左边必须包含候选键**（即所有决定因素都是超键） | 比 3NF 更严格，消除主属性对键的部分与传递依赖  |
| **4NF**  | 第四范式        | 在 BCNF 基础上，**消除非平凡多值依赖**                       | 解决多值依赖导致的冗余                         |

**简单记忆：**

- **1NF**：字段是原子。
- **2NF**：不存在非主属性对主键的**部分依赖**。
- **3NF**：不存在非主属性对主键的**传递依赖**。
- **BCNF**：所有依赖的左边是超键。
- **4NF**：消除非平凡多值依赖。

>例题：
>
>假设员工关系EMP(员工号，姓名，性别，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门只能有一部电话和一位负责人，一个员工可以有多个家庭成员，那么关系EMP属于（ ），且（ ）问题；为了解决这一问题，应该将员工关系EMP分解为 

从上述语义可以得出下列函数依赖和多值依赖

- FD1: 员工号 → 姓名, 性别, 部门, 部门电话, 部门负责人, 家庭住址
- FD2: 部门 → 部门电话, 部门负责人
- MVD: 员工号 →→ 家庭成员 （成员关系随（员工号,家庭成员）而定）

可以推出关系 EMP 的候选键是 **(员工号，家庭成员)**

检查范式：

- 非主属性：姓名, 性别, 部门, 部门电话, 部门负责人, 家庭住址, 成员关系
- 成员关系 完全依赖于候选键（员工号,家庭成员），没问题。
- 但 姓名, 性别, 部门, 部门电话, 部门负责人, 家庭住址 只依赖于 员工号，即部分依赖于候选键（因为候选键是（员工号,家庭成员）），所以 **不满足 2NF**。

因此 EMP 属于 **1NF**。

**存在的问题**

由于存在部分依赖，会导致：

1. **数据冗余**：同一个员工的部门、部门电话、负责人等信息在每一个家庭成员元组中重复存储。
2. **插入异常**：如果新员工还没有家庭成员，则无法插入（因为家庭成员是主键的一部分，不能为空）
3. **删除异常**：如果删除某个员工的最后一个家庭成员元组，会连带删除员工的基本信息。
4. **更新异常**：修改员工的部门电话，需要修改该员工对应的所有家庭成员元组，否则不一致。

所以问题描述是：**存在冗余、修改操作的不一致，以及插入异常和删除异常**。

**如何分解**

为了消除部分依赖和多值依赖带来的问题，应该做如下分解：

1. **先消除多值依赖**（员工号 →→ 家庭成员）：
   - R1(员工号, 家庭成员, 成员关系) —— 描述家庭成员关系
   - R2(员工号, 姓名, 性别, 部门, 部门电话, 部门负责人, 家庭住址) —— 描述员工基本信息
2. **再消除R2中的传递依赖/部分依赖？**
   在 R2 中，候选键是 员工号，但存在 部门 → 部门电话, 部门负责人，这是非主属性对候选键的传递依赖（员工号 → 部门 → 部门电话）。
   所以 R2 不满足 3NF。
   继续分解：
   - R21(员工号, 姓名, 性别, 部门, 家庭住址)
   - R22(部门, 部门电话, 部门负责人)

最终分解为：

- 员工家庭成员表（员工号，家庭成员，成员关系）
- 员工表（员工号，姓名，性别，部门，家庭住址）
- 部门表（部门，部门电话，部门负责人）

# 科目二 案例分析

![image-20240512210055973](https://cdn.fengxianhub.top/resources-master/image-20240512210055973.png)



![image-20240518130557501](https://cdn.fengxianhub.top/resources-master/image-20240518130557501.png)

![image-20240518130658187](https://cdn.fengxianhub.top/resources-master/image-20240518130658187.png)



![image-20241027143233807](https://cdn.fengxianhub.top/resources-master/image-20241027143233807.png)

>考试注意点：
>
>- 标出问题要点，以此作为主要线索进行分析和思考
>- 对照问题要点仔细阅读正文
>- 通过定性分析或者定量估算，构造答案的要点
>- 以最简练的语言写出答案（不能只写答案，不写过程）
>
>考点分析
>
>- 可以看出redis几乎每年必考，24年上半年还考了redis zset的命令

## 1. 通信系统架构的设计理论与实践

### 1.1 通讯系统网络架构

- 局域网
- 广域网
- 移动通信网

![image-20241027150043099](https://cdn.fengxianhub.top/resources-master/image-20241027150043099.png)

### 1.2 存储网络架构

- 直连式存储（DAS）
- 网络附加存储（NAS）
- 存储区域网络（SAN）

![image-20241027150518350](https://cdn.fengxianhub.top/resources-master/image-20241027150518350.png)

### 1.3 软件定义网络技术

![image-20241027150553631](https://cdn.fengxianhub.top/resources-master/image-20241027150553631.png)

### 1.4 高可用网络架构

- 核心层
- 汇聚层
- 接入层

![image-20241027151912645](https://cdn.fengxianhub.top/resources-master/image-20241027151912645.png)

#### 1.4.1 核心层

- 核心层设备是网络的枢纽，需要能提供高速数据交换能力和极高持久性，从系统冗余性角度，应考虑双核心或多核心设备，以主备或负荷分担方式工作
- 就单台设备而言，应选用交换性能和可靠性高的设备，支持主控、电源冗余设计，具备分布式转发特征，并降低设备配置的复杂度，减少出错几率
- 尽量在核心层采用冗余的点到点L3（网络第三层）互连接，这样可提供最快速和确定的收敛结果。将核心层设计为基于硬件加速业务的L3交换环境，要优于L2的设计，因为在链路或街道故障时能提供更快的收敛速度，通过减少路由邻接关系和网络拓扑可提高可拓展性，通过等价多路径（ECMP）可提高带宽利用率



#### 1.4.2 汇聚层

- 汇聚层的高可用通过`两条等成本路径`来提供，包括从汇聚层到核心以及从接入层到汇聚层的链路，可在链路或节点发生故障时提供确定性的快速收敛。当冗余路径存在时，故障切换主要依赖硬件链路故障检测，而不是基于定时器的软件故障检测
- 汇聚层使用`网络负载平衡协议（GLBP）、热备份路由器协议（HSRP）或虚拟路由器冗余协议（VRRP）提供缺省的网关冗余`。当一个汇聚层节点发生故障或被拆除时，不会影响端点与缺省网关的连接



#### 1.4.3 接入层

![image-20241027153142185](https://cdn.fengxianhub.top/resources-master/image-20241027153142185.png)

#### 小结

![image-20241027152739158](https://cdn.fengxianhub.top/resources-master/image-20241027152739158.png)



### 1.5 网络安全

网络安全技术有：

- 防火墙部署
- VPN技术
- 访问控制技术（ACL）
- 网络安全隔离
- 网络安全协议
- 网络安全审计

![image-20241027164919250](https://cdn.fengxianhub.top/resources-master/image-20241027164919250.png)

### 1.6 例题

![image-20241027153303406](https://cdn.fengxianhub.top/resources-master/image-20241027153303406.png)

<details>
<summary>答案</summary>
<pre>
问题一：
- 核心层：负责高速数据转发，是网络的骨干。它提供最优路径选择和快速的数据传输能力，通常不执行策略控制或数据包过滤以保持高性能。
- 汇聚层：作为连接核心层与接入层的桥梁，主要处理路由聚合、安全策略实施（如防火墙）、服务质量（QoS）管理等。它还可能包含一些冗余机制来提高网络可靠性。
- 接入层：直接面向终端用户和设备，负责将它们连接到网络。这一层实现用户访问控制、MAC地址过滤等功能，并且是进行VLAN划分的主要场所，有助于隔离广播域和增强安全性。
问题二：
答题关键点：冗余设备、冗余连接
第一部分：
- 接入层：硬件冗余：冗余引擎和冗余电源获得系统级冗余；接入和线路冗余：双归宿连接，获得默认网关冗余，支持在汇聚层的主备交换机间快速实现故障切换
- 汇聚层：。。。就是上面的表格
第二部分：
- 特点：从汇聚层到核心层具有全冗余链路和转发路径
- 优点：高可用，故障自动收敛
- 缺点：成本高、难以维护
</pre>
</details>
例题二

![image-20241027163142973](https://cdn.fengxianhub.top/resources-master/image-20241027163142973.png)

<details>
<summary>答案</summary>
<pre>
问题三：
双栈（Dual Stack）：在同一网络设备上同时支持IPv4和IPv6两种协议栈。这意味着该设备能够处理来自IPv4或IPv6的数据包，并且可以与使用任一版本IP地址的其他设备通信。
隧道技术（Tunneling）：
手动配置的隧道：管理员手动配置特定的IPv6-over-IPv4或IPv4-over-IPv6隧道。
自动隧道：例如6to4、Teredo等，这些技术允许自动创建隧道以便在IPv4网络中传输IPv6数据包。
ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）：用于站点内部的IPv6 over IPv4自动隧道。
NAT-PT (Network Address Translation - Protocol Translation)：这是一种早期的方法，通过将IPv4地址转换为IPv6地址或反之亦然来实现互通。但由于存在一些性能问题及复杂性，它已被认为是过时的技术。
NAT64/DNS64：结合了DNS64域名解析技术和NAT64网关功能，使得纯IPv6客户端可以通过合成的AAAA记录访问IPv4服务器。这种方法主要用于解决IPv6客户端访问IPv4资源的问题。
DS-Lite (Dual-Stack Lite)：专为宽带服务提供商设计的一种过渡方案，通过集中式NAT设备使IPv6用户能够访问IPv4互联网。
464XLAT：允许移动设备仅使用IPv6连接，而应用程序仍然可以像平常一样使用IPv4地址进行通信。这通常与DS-Lite一起部署，在终端设备上实现IPv4-to-IPv6的翻译。
</pre>
</details>


## 2. 数据库设计

### 提要

- 范式化与反范式化
- 索引与视图
- 分布式数据库
- NoSQL
- 内存数据库

**考情分析**

![image-20241027170838864](https://cdn.fengxianhub.top/resources-master/image-20241027170838864.png)



### 2.1 数据库性能优化

![image-20241027171317827](https://cdn.fengxianhub.top/resources-master/image-20241027171317827.png)





### 例题

![image-20241027171422025](https://cdn.fengxianhub.top/resources-master/image-20241027171422025.png)



问题一：

1. **增加冗余列**：
   - 在一个表中复制另一个相关表中的某些列。例如，在订单详情表中除了存储商品ID外，还可以直接存储商品名称、价格等信息，这样可以减少关联查询的需求。
2. **预计算汇总数据**：
   - 创建额外的表或字段来保存预先计算好的汇总值，如总数、平均数、最大/最小值等。这些汇总数据可以在插入或更新时维护，从而加快报表生成和数据分析的速度。
3. **创建派生表**：
   - 基于现有数据生成新的表，其中包含经常使用的复杂查询结果。这类表需要定期更新以保持与源数据的一致性。
4. **宽表结构**：
   - 将多个相关的实体合并到一个更宽的表中，使得单次查询就能获取到所有相关信息，而不是通过多个连接操作来实现。
5. **嵌套集合模型**：
   - 用于高效地表示层次结构的数据模型，比如组织结构或分类目录。这种模型通过增加额外的左、右值来快速定位节点及其子节点。
6. **使用JSON/XML类型字段**：
   - 在某些现代数据库系统中支持非结构化的数据类型，允许在一个字段内存储复杂的、多层级的信息结构。这种方式可以简化数据建模但可能牺牲了部分查询灵活性。
7. **缓存常用视图**：
   - 对于复杂的视图或者频繁访问的数据集，可以考虑将其物化为实际的表，并定期刷新这些“物化视图”以保持最新状态。

问题二：

1. **事务管理**：
   - 使用数据库事务来确保数据的一致性。在更新冗余数据时，将相关的操作放在同一个事务中执行，这样可以保证要么所有更改都成功提交，要么都不提交，从而保持数据的一致性。
2. **触发器（Triggers）**：
   - 在数据库中设置触发器，当基础数据发生变化时自动更新冗余的数据。例如，当一个订单的详细信息被修改时，可以通过触发器同步更新订单表中的相关字段。
3. **应用程序逻辑**：
   - 通过应用程序代码来维护数据的一致性。这通常涉及到在业务逻辑层编写额外的代码来处理数据更新，并确保在更新主表的同时也正确地更新了冗余数据。
4. **定期批处理作业**：
   - 对于那些对实时一致性要求不是特别高的情况，可以使用定期运行的批处理作业来同步和校正冗余数据。这种方法可以在非高峰时段执行，减少对系统性能的影响。
5. **使用缓存技术**：
   - 利用缓存机制存储频繁访问的数据副本，而不是直接存储在数据库中。这种方式可以减少数据库的写入压力，并且可以通过适当的缓存失效策略来保持数据的新鲜度。
6. **最终一致性模型**：
   - 接受一定程度的数据延迟，在某些情况下采用最终一致性模型可能是可行的。这意味着数据在一段时间内可能会处于不一致状态，但在经过一系列操作后会达到一致状态。这种模式常见于分布式系统中。
7. **版本控制**：
   - 为每个记录引入版本号或其他标识符，以跟踪其变化历史。当检测到潜在的数据不一致时，可以根据版本信息进行修正。
8. **监控与审计**：
   - 实施强大的监控和日志记录机制，以便快速发现并响应数据不一致的问题。同时，定期进行数据完整性检查也是很重要的。



![image-20241027174730255](https://cdn.fengxianhub.top/resources-master/image-20241027174730255.png)

![image-20241027174814720](https://cdn.fengxianhub.top/resources-master/image-20241027174814720.png)

![image-20241027174829784](https://cdn.fengxianhub.top/resources-master/image-20241027174829784.png)

![image-20241027175030332](https://cdn.fengxianhub.top/resources-master/image-20241027175030332.png)

## 3. 大数据拓展篇

大数据技术

- 大数据处理系统概述
- Lambda架构
- Kappa架构
- Lambda架构与kappa架构对比和设计选择

### 3.1 大数据特点

五个V：

- 大规模（Volume）
- 高速度（Velocity）
- 多样化（Variety）
- 价值密度低（Value）
- 真实性（Veracity）

![image-20241028001950342](https://cdn.fengxianhub.top/resources-master/image-20241028001950342.png)



### 3.2 大数据架构

![image-20241028002442282](https://cdn.fengxianhub.top/resources-master/image-20241028002442282.png)

- OLAP：联机分析
- OLTP：联机事务

![image-20241028002455462](https://cdn.fengxianhub.top/resources-master/image-20241028002455462.png)

### 3.3 Lambda架构

![image-20241028002522004](https://cdn.fengxianhub.top/resources-master/image-20241028002522004.png)

![image-20241028002620529](https://cdn.fengxianhub.top/resources-master/image-20241028002620529.png)

![image-20241028002633744](https://cdn.fengxianhub.top/resources-master/image-20241028002633744.png)

### 3.4 Kappa架构

![image-20241028003011768](https://cdn.fengxianhub.top/resources-master/image-20241028003011768.png)



![image-20241028003028207](https://cdn.fengxianhub.top/resources-master/image-20241028003028207.png)

### 3.5 Kappa+架构

![image-20241028003053468](https://cdn.fengxianhub.top/resources-master/image-20241028003053468.png)

![image-20241028003106080](https://cdn.fengxianhub.top/resources-master/image-20241028003106080.png)

>存储能力上来看，Lambda要求更高一些，因为有大量的离线数据；Kappa由于没有离线数据，要求会低一些

![image-20241028003127943](https://cdn.fengxianhub.top/resources-master/image-20241028003127943.png)

![image-20241028003205099](https://cdn.fengxianhub.top/resources-master/image-20241028003205099.png)

### 例题一

![image-20241103151438495](https://cdn.fengxianhub.top/resources-master/image-20241103151438495.png)

![image-20241103151449390](https://cdn.fengxianhub.top/resources-master/image-20241103151449390.png)

![image-20241102001232696](https://cdn.fengxianhub.top/resources-master/image-20241102001232696.png)

![image-20241102001244791](https://cdn.fengxianhub.top/resources-master/image-20241102001244791.png)

答案

问题一：

1. Kappa只需要维护一套系统（引擎），复杂度低，开发维护成本低
2. Kappa架构开发、维护成本相对较低
3. 满足实时性
4. 流式全量处理，吞吐量相对较低，历史数据处理能力相对较弱

问题二：

1. Kappa只需要维护一套系统（引擎），复杂度低，开发维护成本低
2. Kappa架构开发、维护成本相对较低
3. 本系统可以使用Flink计算引擎，对于Hadoop、Spark、Storm等技术没有强制性的依赖
4. 本系统根据用户实时的点击、出价以及广告的曝光进行分析，关注的主要是实时数据，数据系统规模不大，流处理系统完全可以使用，应该选择Kappa架构

![image-20241103152729133](https://cdn.fengxianhub.top/resources-master/image-20241103152729133.png)





## 4. 软件工程

>重点是
>
>1. 需求分析
>2. 面向对象设计

### 4.1 结构化需求分析（SA）

重点放在数据`分层数据流图（DFD）` => 自顶向下、逐步求精（跟结构化开发高度匹配）

![image-20241103160302436](https://cdn.fengxianhub.top/resources-master/image-20241103160302436.png)

![image-20241103161313272](https://cdn.fengxianhub.top/resources-master/image-20241103161313272.png)



#### 4.1.1 数据流图平衡原则

![image-20241103161058936](https://cdn.fengxianhub.top/resources-master/image-20241103161058936.png)

#### 4.1.2 类图和对象图

![image-20241103202622844](https://cdn.fengxianhub.top/resources-master/image-20241103202622844.png)

>泛化指向的是父类；关联指向的是整体

组合关系，生命周期一样，可能会导致内存垃圾

- 汽车与轮胎是聚合关系，汽车坏了，轮胎还能给其他汽车用
- 公司和部门是组合，公司倒闭了，部门也没有存在的必要了

>类分为三种：实体类、边界类、控制类 

### 例题

![image-20241103210253061](https://cdn.fengxianhub.top/resources-master/image-20241103210253061.png)

![image-20241103203659538](https://cdn.fengxianhub.top/resources-master/image-20241103203659538.png)

答案：B、A（交互是动态图，其他都是静态图；活动图）

![image-20241103175331756](https://cdn.fengxianhub.top/resources-master/image-20241103175331756.png)

![image-20241103175342284](https://cdn.fengxianhub.top/resources-master/image-20241103175342284.png)

>练习题

![image-20241103175359239](https://cdn.fengxianhub.top/resources-master/image-20241103175359239.png)

![image-20241103175416758](https://cdn.fengxianhub.top/resources-master/image-20241103175416758.png)

![image-20241103231849903](https://cdn.fengxianhub.top/resources-master/image-20241103231849903.png)

![image-20241103231914135](https://cdn.fengxianhub.top/resources-master/image-20241103231914135.png)



>答案

![image-20241103232408291](https://cdn.fengxianhub.top/resources-master/image-20241103232408291.png)

>例题

![image-20241103234959687](https://cdn.fengxianhub.top/resources-master/image-20241103234959687.png)

![image-20241103235126472](https://cdn.fengxianhub.top/resources-master/image-20241103235126472.png)

>答案

![image-20241103235508572](https://cdn.fengxianhub.top/resources-master/image-20241103235508572.png)

### 4.2 系统工程建模

系统工程是软件工程的超集

![image-20241103235642545](https://cdn.fengxianhub.top/resources-master/image-20241103235642545.png)

![image-20241104221426418](https://cdn.fengxianhub.top/resources-master/image-20241104221426418.png)

#### 4.2.1 需求图

![image-20241104221450247](https://cdn.fengxianhub.top/resources-master/image-20241104221450247.png)

![image-20241104221455507](https://cdn.fengxianhub.top/resources-master/image-20241104221455507.png)

## 5. 架构设计篇

![image-20241104222149424](https://cdn.fengxianhub.top/resources-master/image-20241104222149424.png)

### 5.1 软件架构风格

>软件架构风格描述某一特定领域中的系统组织方式和惯用模式，反映了领域中众多系统所共有的`结构和语义`两个方面的特征。

![image-20241104225021400](https://cdn.fengxianhub.top/resources-master/image-20241104225021400.png)

>例题

![image-20241105232251509](https://cdn.fengxianhub.top/resources-master/image-20241105232251509.png)

![image-20241107000416991](https://cdn.fengxianhub.top/resources-master/image-20241107000416991.png)

>答案

![image-20241107004434694](https://cdn.fengxianhub.top/resources-master/image-20241107004434694.png)

![image-20241107004443071](https://cdn.fengxianhub.top/resources-master/image-20241107004443071.png)

### 5.2 云原生架构

![image-20241108231720411](https://cdn.fengxianhub.top/resources-master/image-20241108231720411.png)

![image-20241108231732494](https://cdn.fengxianhub.top/resources-master/image-20241108231732494.png)

二、云原生架构的设计原则具体描述如下：
(1) 服务化原则。当代码规模超出小团队的合作范围时，就有必要进行服务化拆分，包括拆分为微服务架构、小服务（mini service)架构，通过服务化架构把不同生命周期的模块分离出来，分别进行业务迭代，避免迭代频繁模块被慢速模块拖慢，从而加快整体的进度和稳定性。同时服务化架构以面向接口编程，服务内部的功能高度内聚，模块间通过公共功能模块的提取增加软件的复用程度。
(2) 弹性原则。大部分系统部署上线需要根据业务量的估算，准备一定规模的机器，传统上线过程中需要经历采购申请、供应商洽谈、机器部署上电、软件部署、性能压测等阶段，周期很长，重新调整也非常困难。针对这种情况，弹性原则是指系统的部署规模可以随着业务的变化自动伸缩，无须根据事先的容量规划准备固定的硬件和软件资源，从而提高资源利用率，降低成本。
(3) 可观测原则。可观测性原则是指主动通过日志、链路跟踪和度量等手段，每次业务请求背后的多次服务调用的耗时、返回值和参数都清晰可见，甚至可以下钻到三方软件调用、SQL请求、节点拓扑、网络响应等。具备可观测能力可以使运维、开发和业务人员实时掌握软件运行情况，并结合多个维度的数据指标，获得前所未有的关联分析能力，不断对业务健康度和用户体验进行数字化衡量和持续优化。
(4) 韧性原则。韧性原则是指当软件所依赖的软硬件组件出现各种异常时，软件需要表现出抵御能力，这些异常通常包括硬件故障、硬件资源瓶颈、业务流量超出软件设计能力、故障和灾难、软件bug、黑客攻击等对业务可用性带来致命影响的因素。韧性从多个维度诠释了软件持续提供业务服务的能力，核心目标是提升软件的MTBF (Meai Time Between Failure,平均无故障时间）。
(5) 自动化原则。自动化原则是指通过多种技术手段和自动化交付工具，一方面标准化企业内部的软件交付过程，另一方面在标准化的基础上进行自动化，通过配置数据“描述和面向终态 的交付过程，让自动化工具理解交付目标和环境差异，实现整个软件交付和运维的自动化。
三、论文中需要结合项目实际工作，详细论述在项目中是如何采用云原生架构进行系统的设计与实现的，并围绕云原生架构的设计原则，论述遇到了哪些实际问题.，是采用何种方法解决的。

### 5.3 系统架构评估

![image-20241108233032247](https://cdn.fengxianhub.top/resources-master/image-20241108233032247.png)



### 5.4 论软件维护方法及其应用



>例题

试题二论软件维护方法及其应用

 软件维护是指在软件交付使用后，直至软件被淘汰的整个时间范围内，为了改正错误或满足新的需求而修改软件

的活动。在软件系统运行过程中，软件需要维护的原因是多种多样的,根据维护的原因不同，可以将软件维护分为

改正性维护、适应性维护、完善性维护和预防性维护。在维护的过程中，也需要对软件的可维护性进行度量。在软

件外部，一般采用MTTR来度量软件的可维护性;在软件内部，可以通过度量软件的复杂性来间接度量软件的可维护

性。据统计，软件维护阶段占整个软件生命周期60%以上的时间。因此，分析影响软件维护的因素,度量和提高软

件的可维护性，就显得十分重要。

 请围绕“软件维护方法及其应用""论题，依次从以下三个方面进行论述。

 1．概要叙述你参与管理和开发的软件项目，以及你在其中所承担的主要工作。

 2.详细论述影响软件维护工作的因素有哪些。

 3.结合你具体参与管理和开发的实际项目，说明在具体维护过程中，如何度量软件的可维护性,说明具体的软件维护工作类型。

## -1 案例题押题

![image-20241105232847060](https://cdn.fengxianhub.top/resources-master/image-20241105232847060.png)

![image-20241105232913540](https://cdn.fengxianhub.top/resources-master/image-20241105232913540.png)

>答案

![image-20241105232918830](https://cdn.fengxianhub.top/resources-master/image-20241105232918830.png)





# 科目三

## 考试大纲

- 系统建模
- 系统架构设计
- 系统设计
- 分布式系统设计
- 系统可靠性分析与设计
- 系统安全性和保密性设计

**2024下半年论文预测**

![image-20241109143857478](https://cdn.fengxianhub.top/resources-master/image-20241109143857478.png)



## 1. 论文模板

>- https://blog.csdn.net/weixin_50720967/article/details/143571460
>- 微服务：https://blog.csdn.net/weixin_50720967/article/details/143592203





### 1.1 论软件系统架构风格

![image-20241109143503683](https://cdn.fengxianhub.top/resources-master/image-20241109143503683.png)

![image-20241109143639842](https://cdn.fengxianhub.top/resources-master/image-20241109143639842.png)

![image-20241109143706895](https://cdn.fengxianhub.top/resources-master/image-20241109143706895.png)



### 1.2 微服务架构设计

![image-20241109143943047](https://cdn.fengxianhub.top/resources-master/image-20241109143943047.png)

![image-20241109144123314](https://cdn.fengxianhub.top/resources-master/image-20241109144123314.png)





# 题目梳理

1. 遗产系统（Legacy System）的演化策略分为淘汰策略、继承策略、改造策略和集成策略。具有（请作答此空）特点的系统适合用继承策略演化。实施该策略时，应（ ）

![image-20250510005540020](https://cdn.fengxianhub.top/resources-master/image-20250510005540020.png)

>1. 淘汰策略
>
>第三象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的业务价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。完全淘汰是一种极端性策略，一般是企业的业务产生了根本变化，遗留系统已经基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。
>
>对遗留系统的完全淘汰是企业资源的根本浪费，系统分析师应该通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。
>
>2. 继承策略
>
>第二象限为低水平、高价值区，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。
>
>3. 改造策略
>
>第一象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有极大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。
>
>4. 集成策略
>
>第四象限为高水平、低价值区，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。

2. 在服务端构件模型的典型解决方案中,（ ）较为适用于应用服务器
   - EJB (Enterprise Java Beans)是运行在独立服务器上的组件
   - COM+是Microsoft组件对象模型(COM)和 Microsoft Transaction Server (MTS)的演变。COM+可用于开发适用于Windows的企业范围、任务关键型分布式应用程序
   - Servlet (Server Applet)是Java Servlet的简称,称为小服务程序或服务连接器
   - ASP即Active Server Pages，是Microsoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。



3. 基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶

   - 关键字分类法：根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。
   - 刻面分类法：利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。
   - 超文本方法：基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。

4. `CMM能力成熟度模型`（Capacity Maturity Model）是用来指导软件过程改进的。

5. 常见的攻击方式

   1. ### **被动攻击（Passive Attack）** ✅

      - **特点**：攻击者**仅监听或窃取数据**，不直接破坏系统。
      - **目的**：获取敏感信息（如密码、通信内容）。
      - **示例**：
        - **嗅探（Sniffing）**：截获网络数据包（如Wireshark抓包）。
        - **流量分析（Traffic Analysis）**：通过通信模式推断信息。
      - **防御**：加密（如SSL/TLS）、VPN。

      ------

      ### **2. 主动攻击（Active Attack）** ✅

      - **特点**：攻击者**主动破坏系统或数据**。
      - **目的**：篡改、伪造、拒绝服务等。
      - **示例**：
        - **中间人攻击（MITM）**：篡改通信内容。
        - **拒绝服务（DoS/DDoS）**：使服务不可用。
        - **SQL注入**：通过恶意输入破坏数据库。
      - **防御**：防火墙、入侵检测系统（IDS）、输入验证。

      ------

      ### **3. 物理攻击（Physical Attack）**

      - **特点**：针对**硬件或物理设施**的攻击。
      - **示例**：
        - 窃取硬盘、破坏服务器、侧信道攻击（如通过功耗分析窃取密钥）。
      - **防御**：物理隔离、监控、防篡改设备。

      ------

      ### **4. 分发攻击（Distribution Attack）**

      - **特点**：在软件/硬件**分发过程中植入恶意代码**。
      - **示例**：
        - 供应链攻击（如SolarWinds事件）。
        - 篡改软件更新包。
      - **防御**：代码签名、完整性校验、可信来源验证。

   6. 面向对象的分析模型主要由`顶层架构图、用例与用例图和领域概念模型`构成；设计模型则包含以`包图`表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。

   7. 软件设计包括体系结构设计、接口设计、数据设计和过程设计。

      (1) 结构设计：定义软件系统各主要部件之间的关系。

      (2) 数据设计：将模型转换成数据结构的定义，好的数据设计将改善程序结构和模块划 分，降低过程复杂性。

      (3) 接口设计(人机界面设计)：软件内部、软件和操作系统之间，以及软件和人之间 如何通信。

      (4) 过程设计：系统结构部件转换成软件的过程描述。













































